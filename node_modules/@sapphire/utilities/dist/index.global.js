var SapphireUtilities = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    arrayStrictEquals: () => arrayStrictEquals,
    chunk: () => chunk,
    classExtends: () => classExtends,
    codeBlock: () => codeBlock,
    cutText: () => cutText,
    debounce: () => debounce,
    deepClone: () => deepClone,
    filterNullAndUndefined: () => filterNullAndUndefined,
    filterNullAndUndefinedAndEmpty: () => filterNullAndUndefinedAndEmpty,
    filterNullAndUndefinedAndZero: () => filterNullAndUndefinedAndZero,
    filterNullish: () => filterNullAndUndefined,
    filterNullishOrEmpty: () => filterNullAndUndefinedAndEmpty,
    filterNullishOrZero: () => filterNullAndUndefinedAndZero,
    hasAtLeastOneKeyInMap: () => hasAtLeastOneKeyInMap,
    inlineCodeBlock: () => inlineCodeBlock,
    isClass: () => isClass,
    isFunction: () => isFunction,
    isNullOrUndefined: () => isNullOrUndefined,
    isNullOrUndefinedOrEmpty: () => isNullOrUndefinedOrEmpty,
    isNullOrUndefinedOrZero: () => isNullOrUndefinedOrZero,
    isNullish: () => isNullOrUndefined,
    isNullishOrEmpty: () => isNullOrUndefinedOrEmpty,
    isNullishOrZero: () => isNullOrUndefinedOrZero,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isThenable: () => isThenable,
    makeObject: () => makeObject,
    mergeDefault: () => mergeDefault,
    mergeObjects: () => mergeObjects,
    noop: () => noop,
    objectToTuples: () => objectToTuples,
    parseURL: () => parseURL,
    partition: () => partition,
    range: () => range,
    regExpEsc: () => regExpEsc,
    roundNumber: () => roundNumber,
    splitText: () => splitText,
    toTitleCase: () => toTitleCase,
    tryParse: () => tryParse
  });

  // src/lib/arrayStrictEquals.ts
  function arrayStrictEquals(arr1, arr2) {
    if (arr1 === arr2)
      return true;
    if (arr1.length !== arr2.length)
      return false;
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i])
        return false;
    }
    return true;
  }
  __name(arrayStrictEquals, "arrayStrictEquals");

  // src/lib/chunk.ts
  function chunk(array, chunkSize) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!Number.isInteger(chunkSize))
      throw new TypeError("chunkSize must be an integer.");
    if (chunkSize < 1)
      throw new RangeError("chunkSize must be 1 or greater.");
    const clone = array.slice();
    const chunks = [];
    while (clone.length)
      chunks.push(clone.splice(0, chunkSize));
    return chunks;
  }
  __name(chunk, "chunk");

  // src/lib/classExtends.ts
  function classExtends(value, base) {
    let ctor = value;
    while (ctor !== null) {
      if (ctor === base)
        return true;
      ctor = Object.getPrototypeOf(ctor);
    }
    return false;
  }
  __name(classExtends, "classExtends");

  // src/lib/codeBlock.ts
  var zws = String.fromCharCode(8203);
  function codeBlock(language, expression) {
    if (typeof expression === "string") {
      if (expression.length === 0)
        return `\`\`\`${zws}\`\`\``;
      return `\`\`\`${language}
${expression.replace(/```/, `\`${zws}\`\``).replace(/`$/g, `\`${zws}`)}\`\`\``;
    }
    return `\`\`\`${language}
${expression || zws}\`\`\``;
  }
  __name(codeBlock, "codeBlock");

  // src/lib/splitText.ts
  function splitText(str, length, char = " ") {
    const x = str.substring(0, length).lastIndexOf(char);
    const pos = x === -1 ? length : x;
    return str.substring(0, pos);
  }
  __name(splitText, "splitText");

  // src/lib/cutText.ts
  function cutText(str, length) {
    if (str.length < length)
      return str;
    const cut = splitText(str, length - 3);
    if (cut.length < length - 3)
      return `${cut}...`;
    return `${cut.slice(0, length - 3)}...`;
  }
  __name(cutText, "cutText");

  // src/lib/debounce/index.ts
  function debounce(func, options = {}) {
    var _a;
    let lastArgs;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    const wait = (_a = options.wait) != null ? _a : 0;
    const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
    function invokeFunc(time) {
      const args = lastArgs;
      lastArgs = void 0;
      lastInvokeTime = time;
      result = func(...args);
      return result;
    }
    __name(invokeFunc, "invokeFunc");
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return result;
    }
    __name(leadingEdge, "leadingEdge");
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const result2 = wait - timeSinceLastCall;
      return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
    }
    __name(remainingWait, "remainingWait");
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
    }
    __name(shouldInvoke, "shouldInvoke");
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        trailingEdge(time);
        return;
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    __name(timerExpired, "timerExpired");
    function trailingEdge(time) {
      timerId = void 0;
      return invokeFunc(time);
    }
    __name(trailingEdge, "trailingEdge");
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = void 0;
      lastCallTime = void 0;
      timerId = void 0;
    }
    __name(cancel, "cancel");
    function flush() {
      return timerId === void 0 ? result : trailingEdge(Date.now());
    }
    __name(flush, "flush");
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxWait !== null) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    __name(debounced, "debounced");
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  __name(debounce, "debounce");

  // src/lib/isPrimitive.ts
  var primitiveTypes = ["string", "bigint", "number", "boolean"];
  function isPrimitive(input) {
    return primitiveTypes.includes(typeof input);
  }
  __name(isPrimitive, "isPrimitive");

  // src/lib/deepClone.ts
  function deepClone(source) {
    if (source === null || isPrimitive(source)) {
      return source;
    }
    if (source instanceof Date) {
      const output = new source.constructor(source);
      return output;
    }
    if (Array.isArray(source)) {
      const output = new source.constructor(source.length);
      for (let i = 0; i < source.length; i++) {
        output[i] = deepClone(source[i]);
      }
      return output;
    }
    if (source instanceof Map) {
      const output = new source.constructor();
      for (const [key, value] of source.entries()) {
        output.set(key, deepClone(value));
      }
      return output;
    }
    if (source instanceof Set) {
      const output = new source.constructor();
      for (const value of source.values()) {
        output.add(deepClone(value));
      }
      return output;
    }
    if (typeof source === "object") {
      const output = new source.constructor();
      for (const [key, value] of Object.entries(source)) {
        Object.defineProperty(output, key, {
          configurable: true,
          enumerable: true,
          value: deepClone(value),
          writable: true
        });
      }
      return output;
    }
    return source;
  }
  __name(deepClone, "deepClone");

  // src/lib/isNullOrUndefined.ts
  function isNullOrUndefined(value) {
    return value === void 0 || value === null;
  }
  __name(isNullOrUndefined, "isNullOrUndefined");

  // src/lib/filterNullAndUndefined.ts
  function filterNullAndUndefined(value) {
    return !isNullOrUndefined(value);
  }
  __name(filterNullAndUndefined, "filterNullAndUndefined");

  // src/lib/isNullOrUndefinedOrEmpty.ts
  function isNullOrUndefinedOrEmpty(value) {
    return isNullOrUndefined(value) || value.length === 0;
  }
  __name(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");

  // src/lib/filterNullAndUndefinedAndEmpty.ts
  function filterNullAndUndefinedAndEmpty(value) {
    return !isNullOrUndefinedOrEmpty(value);
  }
  __name(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");

  // src/lib/isNullOrUndefinedOrZero.ts
  function isNullOrUndefinedOrZero(value) {
    return value === 0 || isNullOrUndefined(value);
  }
  __name(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");

  // src/lib/filterNullAndUndefinedAndZero.ts
  function filterNullAndUndefinedAndZero(value) {
    return !isNullOrUndefinedOrZero(value);
  }
  __name(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");

  // src/lib/hasAtLeastOneKeyInMap.ts
  function hasAtLeastOneKeyInMap(map, keys) {
    return keys.some((key) => map.has(key));
  }
  __name(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");

  // src/lib/inlineCodeBlock.ts
  var zws2 = String.fromCharCode(8203);
  function inlineCodeBlock(input) {
    return `\`${input.replace(/ /g, "\xA0").replace(/`/g, `\`${zws2}`)}\``;
  }
  __name(inlineCodeBlock, "inlineCodeBlock");

  // src/lib/isClass.ts
  function isClass(input) {
    return typeof input === "function" && typeof input.prototype === "object";
  }
  __name(isClass, "isClass");

  // src/lib/isFunction.ts
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");

  // src/lib/isNumber.ts
  function isNumber(input) {
    return typeof input === "number" && !isNaN(input) && Number.isFinite(input);
  }
  __name(isNumber, "isNumber");

  // src/lib/isObject.ts
  function isObject(input, constructorType) {
    return typeof input === "object" && input ? input.constructor === (constructorType != null ? constructorType : Object) : false;
  }
  __name(isObject, "isObject");

  // src/lib/isThenable.ts
  function hasThen(input) {
    return Reflect.has(input, "then") && isFunction(input.then);
  }
  __name(hasThen, "hasThen");
  function hasCatch(input) {
    return Reflect.has(input, "catch") && isFunction(input.catch);
  }
  __name(hasCatch, "hasCatch");
  function isThenable(input) {
    if (typeof input !== "object" || input === null)
      return false;
    return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);
  }
  __name(isThenable, "isThenable");

  // src/lib/makeObject.ts
  function makeObject(path, value, obj = {}) {
    if (path.includes(".")) {
      const route = path.split(".");
      const lastKey = route.pop();
      let reference = obj;
      for (const key of route) {
        if (!reference[key])
          reference[key] = {};
        reference = reference[key];
      }
      reference[lastKey] = value;
    } else {
      obj[path] = value;
    }
    return obj;
  }
  __name(makeObject, "makeObject");

  // src/lib/mergeDefault.ts
  function mergeDefault(base, overwrites) {
    if (!overwrites)
      return deepClone(base);
    for (const [baseKey, baseValue] of Object.entries(base)) {
      const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);
      if (typeof overwritesValueAtBaseKey === "undefined") {
        Reflect.set(overwrites, baseKey, deepClone(baseValue));
      } else if (isObject(overwritesValueAtBaseKey)) {
        Reflect.set(overwrites, baseKey, mergeDefault(baseValue != null ? baseValue : {}, overwritesValueAtBaseKey));
      }
    }
    return overwrites;
  }
  __name(mergeDefault, "mergeDefault");

  // src/lib/mergeObjects.ts
  function mergeObjects(objTarget, objSource) {
    for (const [key, value] of Object.entries(objSource)) {
      const targetValue = Reflect.get(objTarget, key);
      if (isObject(value)) {
        Reflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value) : value);
      } else if (!isObject(targetValue)) {
        Reflect.set(objTarget, key, value);
      }
    }
    return objTarget;
  }
  __name(mergeObjects, "mergeObjects");

  // src/lib/noop.ts
  function noop() {
  }
  __name(noop, "noop");

  // src/lib/objectToTuples.ts
  function objectToTuples(original, prefix = "") {
    const entries = [];
    for (const [key, value] of Object.entries(original)) {
      if (isObject(value)) {
        entries.push(...objectToTuples(value, `${prefix}${key}.`));
      } else {
        entries.push([`${prefix}${key}`, value]);
      }
    }
    return entries;
  }
  __name(objectToTuples, "objectToTuples");

  // src/lib/parseUrl.ts
  function parseURL(url) {
    try {
      return new URL(url);
    } catch {
      return null;
    }
  }
  __name(parseURL, "parseURL");

  // src/lib/partition.ts
  function partition(array, predicate) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!isFunction(predicate))
      throw new TypeError("predicate must be an function that returns a boolean value.");
    const partitionOne = [];
    const partitionTwo = [];
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        partitionOne.push(array[i]);
      } else {
        partitionTwo.push(array[i]);
      }
    }
    return [partitionOne, partitionTwo];
  }
  __name(partition, "partition");

  // src/lib/range.ts
  function range(min, max, step) {
    return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
  }
  __name(range, "range");

  // src/lib/regExpEsc.ts
  var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
  function regExpEsc(str) {
    return str.replace(REGEXPESC, "\\$&");
  }
  __name(regExpEsc, "regExpEsc");

  // src/lib/roundNumber.ts
  function roundNumber(num, scale = 0) {
    if (!num.toString().includes("e")) {
      return Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);
    }
    const arr = `${num}`.split("e");
    let sig = "";
    if (Number(arr[1]) + scale > 0) {
      sig = "+";
    }
    return Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);
  }
  __name(roundNumber, "roundNumber");

  // src/lib/toTitleCase.ts
  var TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\S*/g;
  var baseVariants = {
    textchannel: "TextChannel",
    voicechannel: "VoiceChannel",
    categorychannel: "CategoryChannel",
    guildmember: "GuildMember"
  };
  function toTitleCase(str, options = {}) {
    const { additionalVariants = {}, caseSensitive } = options;
    const titleCaseVariants = {
      ...baseVariants,
      ...caseSensitive ? additionalVariants : Object.entries(additionalVariants).reduce((variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }), {})
    };
    return str.replace(TO_TITLE_CASE, (txt) => {
      var _a;
      return (_a = titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()]) != null ? _a : txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
    });
  }
  __name(toTitleCase, "toTitleCase");

  // src/lib/tryParse.ts
  function tryParse(value) {
    try {
      return JSON.parse(value);
    } catch (err) {
      return value;
    }
  }
  __name(tryParse, "tryParse");
  return __toCommonJS(src_exports);
})();
/**
 * Split a string by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @param char The character to split with
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
/**
 * Split a text by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
//# sourceMappingURL=index.global.js.map