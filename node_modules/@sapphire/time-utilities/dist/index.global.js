var SapphireTimeUtilities = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Cron: () => Cron,
    Duration: () => Duration,
    DurationFormatter: () => DurationFormatter,
    Time: () => Time,
    TimeTypes: () => TimeTypes,
    TimerManager: () => TimerManager,
    Timestamp: () => Timestamp
  });

  // src/lib/constants.ts
  var TimeTypes = /* @__PURE__ */ ((TimeTypes2) => {
    TimeTypes2["Second"] = "second";
    TimeTypes2["Minute"] = "minute";
    TimeTypes2["Hour"] = "hour";
    TimeTypes2["Day"] = "day";
    TimeTypes2["Week"] = "week";
    TimeTypes2["Month"] = "month";
    TimeTypes2["Year"] = "year";
    return TimeTypes2;
  })(TimeTypes || {});
  var Time = /* @__PURE__ */ ((Time2) => {
    Time2[Time2["Millisecond"] = 1] = "Millisecond";
    Time2[Time2["Second"] = 1e3] = "Second";
    Time2[Time2["Minute"] = 6e4] = "Minute";
    Time2[Time2["Hour"] = 36e5] = "Hour";
    Time2[Time2["Day"] = 864e5] = "Day";
    Time2[Time2["Month"] = 2628e6] = "Month";
    Time2[Time2["Year"] = 31536e6] = "Year";
    return Time2;
  })(Time || {});
  var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var tokens = /* @__PURE__ */ new Map([
    ["Y", 4],
    ["Q", 1],
    ["M", 4],
    ["D", 4],
    ["d", 4],
    ["X", 1],
    ["x", 1],
    ["H", 2],
    ["h", 2],
    ["a", 1],
    ["A", 1],
    ["m", 2],
    ["s", 2],
    ["S", 3],
    ["Z", 2],
    ["l", 4],
    ["L", 4],
    ["T", 1],
    ["t", 1]
  ]);
  var partRegex = /^(?:(\*)|(\d+)(?:-(\d+))?)(?:\/(\d+))?$/;
  var wildcardRegex = /\bh\b|\B\?\B/g;
  var allowedNum = [
    [0, 59],
    [0, 23],
    [1, 31],
    [1, 12],
    [0, 6]
  ];
  var predefined = {
    "@annually": "0 0 1 1 *",
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  var cronTokens = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  };
  var tokensRegex = new RegExp(Object.keys(cronTokens).join("|"), "g");
  var DEFAULT_UNITS = {
    ["year" /* Year */]: {
      1: "year",
      DEFAULT: "years"
    },
    ["month" /* Month */]: {
      1: "month",
      DEFAULT: "months"
    },
    ["week" /* Week */]: {
      1: "week",
      DEFAULT: "weeks"
    },
    ["day" /* Day */]: {
      1: "day",
      DEFAULT: "days"
    },
    ["hour" /* Hour */]: {
      1: "hour",
      DEFAULT: "hours"
    },
    ["minute" /* Minute */]: {
      1: "minute",
      DEFAULT: "minutes"
    },
    ["second" /* Second */]: {
      1: "second",
      DEFAULT: "seconds"
    }
  };
  var DEFAULT_SEPARATORS = {
    left: " ",
    right: " "
  };

  // ../utilities/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  function arrayStrictEquals(arr1, arr2) {
    if (arr1 === arr2)
      return true;
    if (arr1.length !== arr2.length)
      return false;
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i])
        return false;
    }
    return true;
  }
  __name(arrayStrictEquals, "arrayStrictEquals");
  __name2(arrayStrictEquals, "arrayStrictEquals");
  function chunk(array, chunkSize) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!Number.isInteger(chunkSize))
      throw new TypeError("chunkSize must be an integer.");
    if (chunkSize < 1)
      throw new RangeError("chunkSize must be 1 or greater.");
    const clone = array.slice();
    const chunks = [];
    while (clone.length)
      chunks.push(clone.splice(0, chunkSize));
    return chunks;
  }
  __name(chunk, "chunk");
  __name2(chunk, "chunk");
  function classExtends(value, base) {
    let ctor = value;
    while (ctor !== null) {
      if (ctor === base)
        return true;
      ctor = Object.getPrototypeOf(ctor);
    }
    return false;
  }
  __name(classExtends, "classExtends");
  __name2(classExtends, "classExtends");
  var zws = String.fromCharCode(8203);
  function codeBlock(language, expression) {
    if (typeof expression === "string") {
      if (expression.length === 0)
        return `\`\`\`${zws}\`\`\``;
      return `\`\`\`${language}
${expression.replace(/```/, `\`${zws}\`\``).replace(/`$/g, `\`${zws}`)}\`\`\``;
    }
    return `\`\`\`${language}
${expression || zws}\`\`\``;
  }
  __name(codeBlock, "codeBlock");
  __name2(codeBlock, "codeBlock");
  function splitText(str, length, char = " ") {
    const x = str.substring(0, length).lastIndexOf(char);
    const pos = x === -1 ? length : x;
    return str.substring(0, pos);
  }
  __name(splitText, "splitText");
  __name2(splitText, "splitText");
  function cutText(str, length) {
    if (str.length < length)
      return str;
    const cut = splitText(str, length - 3);
    if (cut.length < length - 3)
      return `${cut}...`;
    return `${cut.slice(0, length - 3)}...`;
  }
  __name(cutText, "cutText");
  __name2(cutText, "cutText");
  function debounce(func, options = {}) {
    var _a;
    let lastArgs;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    const wait = (_a = options.wait) != null ? _a : 0;
    const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
    function invokeFunc(time) {
      const args = lastArgs;
      lastArgs = void 0;
      lastInvokeTime = time;
      result = func(...args);
      return result;
    }
    __name(invokeFunc, "invokeFunc");
    __name2(invokeFunc, "invokeFunc");
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return result;
    }
    __name(leadingEdge, "leadingEdge");
    __name2(leadingEdge, "leadingEdge");
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const result2 = wait - timeSinceLastCall;
      return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
    }
    __name(remainingWait, "remainingWait");
    __name2(remainingWait, "remainingWait");
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
    }
    __name(shouldInvoke, "shouldInvoke");
    __name2(shouldInvoke, "shouldInvoke");
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        trailingEdge(time);
        return;
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    __name(timerExpired, "timerExpired");
    __name2(timerExpired, "timerExpired");
    function trailingEdge(time) {
      timerId = void 0;
      return invokeFunc(time);
    }
    __name(trailingEdge, "trailingEdge");
    __name2(trailingEdge, "trailingEdge");
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = void 0;
      lastCallTime = void 0;
      timerId = void 0;
    }
    __name(cancel, "cancel");
    __name2(cancel, "cancel");
    function flush() {
      return timerId === void 0 ? result : trailingEdge(Date.now());
    }
    __name(flush, "flush");
    __name2(flush, "flush");
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxWait !== null) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    __name(debounced, "debounced");
    __name2(debounced, "debounced");
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  __name(debounce, "debounce");
  __name2(debounce, "debounce");
  var primitiveTypes = ["string", "bigint", "number", "boolean"];
  function isPrimitive(input) {
    return primitiveTypes.includes(typeof input);
  }
  __name(isPrimitive, "isPrimitive");
  __name2(isPrimitive, "isPrimitive");
  function deepClone(source) {
    if (source === null || isPrimitive(source)) {
      return source;
    }
    if (source instanceof Date) {
      const output = new source.constructor(source);
      return output;
    }
    if (Array.isArray(source)) {
      const output = new source.constructor(source.length);
      for (let i = 0; i < source.length; i++) {
        output[i] = deepClone(source[i]);
      }
      return output;
    }
    if (source instanceof Map) {
      const output = new source.constructor();
      for (const [key, value] of source.entries()) {
        output.set(key, deepClone(value));
      }
      return output;
    }
    if (source instanceof Set) {
      const output = new source.constructor();
      for (const value of source.values()) {
        output.add(deepClone(value));
      }
      return output;
    }
    if (typeof source === "object") {
      const output = new source.constructor();
      for (const [key, value] of Object.entries(source)) {
        Object.defineProperty(output, key, {
          configurable: true,
          enumerable: true,
          value: deepClone(value),
          writable: true
        });
      }
      return output;
    }
    return source;
  }
  __name(deepClone, "deepClone");
  __name2(deepClone, "deepClone");
  function isNullOrUndefined(value) {
    return value === void 0 || value === null;
  }
  __name(isNullOrUndefined, "isNullOrUndefined");
  __name2(isNullOrUndefined, "isNullOrUndefined");
  function filterNullAndUndefined(value) {
    return !isNullOrUndefined(value);
  }
  __name(filterNullAndUndefined, "filterNullAndUndefined");
  __name2(filterNullAndUndefined, "filterNullAndUndefined");
  function isNullOrUndefinedOrEmpty(value) {
    return isNullOrUndefined(value) || value.length === 0;
  }
  __name(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");
  __name2(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");
  function filterNullAndUndefinedAndEmpty(value) {
    return !isNullOrUndefinedOrEmpty(value);
  }
  __name(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");
  __name2(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");
  function isNullOrUndefinedOrZero(value) {
    return value === 0 || isNullOrUndefined(value);
  }
  __name(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");
  __name2(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");
  function filterNullAndUndefinedAndZero(value) {
    return !isNullOrUndefinedOrZero(value);
  }
  __name(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");
  __name2(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");
  function hasAtLeastOneKeyInMap(map, keys) {
    return keys.some((key) => map.has(key));
  }
  __name(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");
  __name2(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");
  var zws2 = String.fromCharCode(8203);
  function inlineCodeBlock(input) {
    return `\`${input.replace(/ /g, "\xA0").replace(/`/g, `\`${zws2}`)}\``;
  }
  __name(inlineCodeBlock, "inlineCodeBlock");
  __name2(inlineCodeBlock, "inlineCodeBlock");
  function isClass(input) {
    return typeof input === "function" && typeof input.prototype === "object";
  }
  __name(isClass, "isClass");
  __name2(isClass, "isClass");
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");
  __name2(isFunction, "isFunction");
  function isNumber(input) {
    return typeof input === "number" && !isNaN(input) && Number.isFinite(input);
  }
  __name(isNumber, "isNumber");
  __name2(isNumber, "isNumber");
  function isObject(input, constructorType) {
    return typeof input === "object" && input ? input.constructor === (constructorType != null ? constructorType : Object) : false;
  }
  __name(isObject, "isObject");
  __name2(isObject, "isObject");
  function hasThen(input) {
    return Reflect.has(input, "then") && isFunction(input.then);
  }
  __name(hasThen, "hasThen");
  __name2(hasThen, "hasThen");
  function hasCatch(input) {
    return Reflect.has(input, "catch") && isFunction(input.catch);
  }
  __name(hasCatch, "hasCatch");
  __name2(hasCatch, "hasCatch");
  function isThenable(input) {
    if (typeof input !== "object" || input === null)
      return false;
    return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);
  }
  __name(isThenable, "isThenable");
  __name2(isThenable, "isThenable");
  function makeObject(path, value, obj = {}) {
    if (path.includes(".")) {
      const route = path.split(".");
      const lastKey = route.pop();
      let reference = obj;
      for (const key of route) {
        if (!reference[key])
          reference[key] = {};
        reference = reference[key];
      }
      reference[lastKey] = value;
    } else {
      obj[path] = value;
    }
    return obj;
  }
  __name(makeObject, "makeObject");
  __name2(makeObject, "makeObject");
  function mergeDefault(base, overwrites) {
    if (!overwrites)
      return deepClone(base);
    for (const [baseKey, baseValue] of Object.entries(base)) {
      const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);
      if (typeof overwritesValueAtBaseKey === "undefined") {
        Reflect.set(overwrites, baseKey, deepClone(baseValue));
      } else if (isObject(overwritesValueAtBaseKey)) {
        Reflect.set(overwrites, baseKey, mergeDefault(baseValue != null ? baseValue : {}, overwritesValueAtBaseKey));
      }
    }
    return overwrites;
  }
  __name(mergeDefault, "mergeDefault");
  __name2(mergeDefault, "mergeDefault");
  function mergeObjects(objTarget, objSource) {
    for (const [key, value] of Object.entries(objSource)) {
      const targetValue = Reflect.get(objTarget, key);
      if (isObject(value)) {
        Reflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value) : value);
      } else if (!isObject(targetValue)) {
        Reflect.set(objTarget, key, value);
      }
    }
    return objTarget;
  }
  __name(mergeObjects, "mergeObjects");
  __name2(mergeObjects, "mergeObjects");
  function noop() {
  }
  __name(noop, "noop");
  __name2(noop, "noop");
  function objectToTuples(original, prefix = "") {
    const entries = [];
    for (const [key, value] of Object.entries(original)) {
      if (isObject(value)) {
        entries.push(...objectToTuples(value, `${prefix}${key}.`));
      } else {
        entries.push([`${prefix}${key}`, value]);
      }
    }
    return entries;
  }
  __name(objectToTuples, "objectToTuples");
  __name2(objectToTuples, "objectToTuples");
  function parseURL(url) {
    try {
      return new URL(url);
    } catch {
      return null;
    }
  }
  __name(parseURL, "parseURL");
  __name2(parseURL, "parseURL");
  function partition(array, predicate) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!isFunction(predicate))
      throw new TypeError("predicate must be an function that returns a boolean value.");
    const partitionOne = [];
    const partitionTwo = [];
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        partitionOne.push(array[i]);
      } else {
        partitionTwo.push(array[i]);
      }
    }
    return [partitionOne, partitionTwo];
  }
  __name(partition, "partition");
  __name2(partition, "partition");
  function range(min, max, step) {
    return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
  }
  __name(range, "range");
  __name2(range, "range");
  var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
  function regExpEsc(str) {
    return str.replace(REGEXPESC, "\\$&");
  }
  __name(regExpEsc, "regExpEsc");
  __name2(regExpEsc, "regExpEsc");
  function roundNumber(num, scale = 0) {
    if (!num.toString().includes("e")) {
      return Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);
    }
    const arr = `${num}`.split("e");
    let sig = "";
    if (Number(arr[1]) + scale > 0) {
      sig = "+";
    }
    return Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);
  }
  __name(roundNumber, "roundNumber");
  __name2(roundNumber, "roundNumber");
  var TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\S*/g;
  var baseVariants = {
    textchannel: "TextChannel",
    voicechannel: "VoiceChannel",
    categorychannel: "CategoryChannel",
    guildmember: "GuildMember"
  };
  function toTitleCase(str, options = {}) {
    const { additionalVariants = {}, caseSensitive } = options;
    const titleCaseVariants = {
      ...baseVariants,
      ...caseSensitive ? additionalVariants : Object.entries(additionalVariants).reduce((variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }), {})
    };
    return str.replace(TO_TITLE_CASE, (txt) => {
      var _a;
      return (_a = titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()]) != null ? _a : txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
    });
  }
  __name(toTitleCase, "toTitleCase");
  __name2(toTitleCase, "toTitleCase");
  function tryParse(value) {
    try {
      return JSON.parse(value);
    } catch (err) {
      return value;
    }
  }
  __name(tryParse, "tryParse");
  __name2(tryParse, "tryParse");

  // src/lib/Cron.ts
  var Cron = class {
    constructor(cron) {
      __publicField(this, "cron");
      __publicField(this, "normalized");
      __publicField(this, "minutes");
      __publicField(this, "hours");
      __publicField(this, "days");
      __publicField(this, "months");
      __publicField(this, "dows");
      this.cron = cron.toLowerCase();
      this.normalized = Cron.normalize(this.cron);
      [this.minutes, this.hours, this.days, this.months, this.dows] = Cron.parseString(this.normalized);
    }
    next(outset = new Date(), origin = true) {
      if (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {
        return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
      }
      if (!origin)
        return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));
      const now = new Date(outset.getTime() + 6e4);
      for (const hour of this.hours) {
        if (hour < now.getUTCHours())
          continue;
        for (const minute of this.minutes) {
          if (hour === now.getUTCHours() && minute < now.getUTCMinutes())
            continue;
          return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));
        }
      }
      return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
    }
    static normalize(cron) {
      if (Reflect.has(predefined, cron))
        return Reflect.get(predefined, cron);
      const now = new Date();
      cron = cron.split(" ").map((val, i) => val.replace(wildcardRegex, (match) => {
        if (match === "h")
          return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();
        if (match === "?") {
          switch (i) {
            case 0:
              return now.getUTCMinutes().toString();
            case 1:
              return now.getUTCHours().toString();
            case 2:
              return now.getUTCDate().toString();
            case 3:
              return now.getUTCMonth().toString();
            case 4:
              return now.getUTCDay().toString();
          }
        }
        return match;
      })).join(" ");
      return cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));
    }
    static parseString(cron) {
      const parts = cron.split(" ");
      if (parts.length !== 5)
        throw new Error("Invalid Cron Provided");
      return parts.map((part, i) => Cron.parsePart(part, i));
    }
    static parsePart(cronPart, id) {
      if (cronPart.includes(",")) {
        const res = [];
        for (const part of cronPart.split(","))
          res.push(...Cron.parsePart(part, id));
        return [...new Set(res)].sort((a, b) => a - b);
      }
      const [, wild, minStr, maxStr, step] = partRegex.exec(cronPart);
      let [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];
      if (wild)
        [min, max] = allowedNum[id];
      else if (!max && !step)
        return [min];
      [min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);
      return range(min, max, parseInt(step, 10) || 1);
    }
  };
  __name(Cron, "Cron");

  // src/lib/Duration.ts
  var tokens2 = /* @__PURE__ */ new Map([
    ["nanosecond", 1 / 1e6],
    ["nanoseconds", 1 / 1e6],
    ["ns", 1 / 1e6],
    ["millisecond", 1],
    ["milliseconds", 1],
    ["ms", 1],
    ["second", 1e3],
    ["seconds", 1e3],
    ["sec", 1e3],
    ["secs", 1e3],
    ["s", 1e3],
    ["minute", 1e3 * 60],
    ["minutes", 1e3 * 60],
    ["min", 1e3 * 60],
    ["mins", 1e3 * 60],
    ["m", 1e3 * 60],
    ["hour", 1e3 * 60 * 60],
    ["hours", 1e3 * 60 * 60],
    ["hr", 1e3 * 60 * 60],
    ["hrs", 1e3 * 60 * 60],
    ["h", 1e3 * 60 * 60],
    ["day", 1e3 * 60 * 60 * 24],
    ["days", 1e3 * 60 * 60 * 24],
    ["d", 1e3 * 60 * 60 * 24],
    ["week", 1e3 * 60 * 60 * 24 * 7],
    ["weeks", 1e3 * 60 * 60 * 24 * 7],
    ["wk", 1e3 * 60 * 60 * 24 * 7],
    ["wks", 1e3 * 60 * 60 * 24 * 7],
    ["w", 1e3 * 60 * 60 * 24 * 7],
    ["month", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
    ["months", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
    ["b", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
    ["mo", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
    ["year", 1e3 * 60 * 60 * 24 * 365.25],
    ["years", 1e3 * 60 * 60 * 24 * 365.25],
    ["yr", 1e3 * 60 * 60 * 24 * 365.25],
    ["yrs", 1e3 * 60 * 60 * 24 * 365.25],
    ["y", 1e3 * 60 * 60 * 24 * 365.25]
  ]);
  var _Duration = class {
    constructor(pattern) {
      __publicField(this, "offset");
      this.offset = _Duration.parse(pattern.toLowerCase());
    }
    get fromNow() {
      return this.dateFrom(new Date());
    }
    dateFrom(date) {
      return new Date(date.getTime() + this.offset);
    }
    static parse(pattern) {
      let result = 0;
      let valid = false;
      pattern.replace(_Duration.kCommaRegex, "").replace(_Duration.kAanRegex, "1").replace(_Duration.kPatternRegex, (_, i, units) => {
        const token = tokens2.get(units);
        if (token !== void 0) {
          result += Number(i) * token;
          valid = true;
        }
        return "";
      });
      return valid ? result : NaN;
    }
  };
  var Duration = _Duration;
  __name(Duration, "Duration");
  __publicField(Duration, "kPatternRegex", /(-?\d*\.?\d+(?:e[-+]?\d+)?)\s*([a-zμ]*)/gi);
  __publicField(Duration, "kCommaRegex", /,/g);
  __publicField(Duration, "kAanRegex", /\ban?\b/gi);

  // src/lib/DurationFormatter.ts
  var kTimeDurations = [
    ["year" /* Year */, 31536e6],
    ["month" /* Month */, 2628e6],
    ["week" /* Week */, 1e3 * 60 * 60 * 24 * 7],
    ["day" /* Day */, 1e3 * 60 * 60 * 24],
    ["hour" /* Hour */, 1e3 * 60 * 60],
    ["minute" /* Minute */, 1e3 * 60],
    ["second" /* Second */, 1e3]
  ];
  var DurationFormatter = class {
    constructor(units = DEFAULT_UNITS) {
      this.units = units;
    }
    format(duration, precision = 7, {
      left: leftSeparator = DEFAULT_SEPARATORS.left,
      right: rightSeparator = DEFAULT_SEPARATORS.right
    } = DEFAULT_SEPARATORS) {
      const output = [];
      const negative = duration < 0;
      if (negative)
        duration *= -1;
      for (const [type, timeDuration] of kTimeDurations) {
        const substraction = duration / timeDuration;
        if (substraction < 1)
          continue;
        const floored = Math.floor(substraction);
        duration -= floored * timeDuration;
        output.push(addUnit(floored, this.units[type], leftSeparator));
        if (output.length >= precision)
          break;
      }
      return `${negative ? "-" : ""}${output.join(rightSeparator) || addUnit(0, this.units.second, leftSeparator)}`;
    }
  };
  __name(DurationFormatter, "DurationFormatter");
  function addUnit(time, unit, separator) {
    if (Reflect.has(unit, time))
      return `${time}${separator}${Reflect.get(unit, time)}`;
    return `${time}${separator}${unit.DEFAULT}`;
  }
  __name(addUnit, "addUnit");

  // src/lib/TimerManager.ts
  var TimerManager = class extends null {
    static setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        this.storedTimeouts.delete(timeout);
        fn(...args);
      }, delay);
      this.storedTimeouts.add(timeout);
      return timeout;
    }
    static clearTimeout(timeout) {
      clearTimeout(timeout);
      this.storedTimeouts.delete(timeout);
    }
    static setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this.storedIntervals.add(interval);
      return interval;
    }
    static clearInterval(interval) {
      clearInterval(interval);
      this.storedIntervals.delete(interval);
    }
    static destroy() {
      for (const i of this.storedTimeouts)
        clearTimeout(i);
      for (const i of this.storedIntervals)
        clearInterval(i);
      this.storedTimeouts.clear();
      this.storedIntervals.clear();
    }
  };
  __name(TimerManager, "TimerManager");
  __publicField(TimerManager, "storedTimeouts", /* @__PURE__ */ new Set());
  __publicField(TimerManager, "storedIntervals", /* @__PURE__ */ new Set());

  // src/lib/Timestamp.ts
  var tokenResolvers = /* @__PURE__ */ new Map([
    ["Y", (time) => String(time.getFullYear()).slice(2)],
    ["YY", (time) => String(time.getFullYear()).slice(2)],
    ["YYY", (time) => String(time.getFullYear())],
    ["YYYY", (time) => String(time.getFullYear())],
    ["Q", (time) => String((time.getMonth() + 1) / 3)],
    ["M", (time) => String(time.getMonth() + 1)],
    ["MM", (time) => String(time.getMonth() + 1).padStart(2, "0")],
    ["MMM", (time) => months[time.getMonth()]],
    ["MMMM", (time) => months[time.getMonth()]],
    ["D", (time) => String(time.getDate())],
    ["DD", (time) => String(time.getDate()).padStart(2, "0")],
    ["DDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
    ["DDDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
    [
      "d",
      (time) => {
        const day = String(time.getDate());
        if (day !== "11" && day.endsWith("1"))
          return `${day}st`;
        if (day !== "12" && day.endsWith("2"))
          return `${day}nd`;
        if (day !== "13" && day.endsWith("3"))
          return `${day}rd`;
        return `${day}th`;
      }
    ],
    ["dd", (time) => days[time.getDay()].slice(0, 2)],
    ["ddd", (time) => days[time.getDay()].slice(0, 3)],
    ["dddd", (time) => days[time.getDay()]],
    ["X", (time) => String(time.valueOf() / 1e3 /* Second */)],
    ["x", (time) => String(time.valueOf())],
    ["H", (time) => String(time.getHours())],
    ["HH", (time) => String(time.getHours()).padStart(2, "0")],
    ["h", (time) => String(time.getHours() % 12 || 12)],
    ["hh", (time) => String(time.getHours() % 12 || 12).padStart(2, "0")],
    ["a", (time) => time.getHours() < 12 ? "am" : "pm"],
    ["A", (time) => time.getHours() < 12 ? "AM" : "PM"],
    ["m", (time) => String(time.getMinutes())],
    ["mm", (time) => String(time.getMinutes()).padStart(2, "0")],
    ["s", (time) => String(time.getSeconds())],
    ["ss", (time) => String(time.getSeconds()).padStart(2, "0")],
    ["S", (time) => String(time.getMilliseconds())],
    ["SS", (time) => String(time.getMilliseconds()).padStart(2, "0")],
    ["SSS", (time) => String(time.getMilliseconds()).padStart(3, "0")],
    ["T", (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`],
    [
      "t",
      (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")}:${String(time.getSeconds()).padStart(2, "0")} ${time.getHours() < 12 ? "am" : "pm"}`
    ],
    ["L", (time) => `${String(time.getMonth() + 1).padStart(2, "0")}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["l", (time) => `${String(time.getMonth() + 1)}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["LL", (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    ["ll", (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    [
      "LLL",
      (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "lll",
      (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "LLLL",
      (time) => `${days[time.getDay()]}, ${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "llll",
      (time) => `${days[time.getDay()].slice(0, 3)} ${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "Z",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ],
    [
      "ZZ",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ]
  ]);
  var Timestamp = class {
    constructor(pattern) {
      __publicField(this, "pattern");
      __publicField(this, "template");
      this.pattern = pattern;
      this.template = Timestamp.parse(pattern);
    }
    display(time = new Date()) {
      return Timestamp.display(this.template, time);
    }
    displayUTC(time) {
      return Timestamp.display(this.template, Timestamp.utc(time));
    }
    edit(pattern) {
      this.pattern = pattern;
      this.template = Timestamp.parse(pattern);
      return this;
    }
    toString() {
      return this.display();
    }
    static displayArbitrary(pattern, time = new Date()) {
      return Timestamp.display(Timestamp.parse(pattern), time);
    }
    static displayUTCArbitrary(pattern, time = new Date()) {
      return Timestamp.display(Timestamp.parse(pattern), Timestamp.utc(time));
    }
    static utc(time = new Date()) {
      time = Timestamp.resolveDate(time);
      return new Date(time.valueOf() + time.getTimezoneOffset() * 6e4);
    }
    static display(template, time) {
      let output = "";
      const parsedTime = Timestamp.resolveDate(time);
      for (const { content, type } of template)
        output += content || tokenResolvers.get(type)(parsedTime);
      return output;
    }
    static parse(pattern) {
      const template = [];
      for (let i = 0; i < pattern.length; i++) {
        let current = "";
        const currentChar = pattern[i];
        const tokenMax = tokens.get(currentChar);
        if (typeof tokenMax === "number") {
          current += currentChar;
          while (pattern[i + 1] === currentChar && current.length < tokenMax)
            current += pattern[++i];
          template.push({ type: current, content: null });
        } else if (currentChar === "[") {
          while (i + 1 < pattern.length && pattern[i + 1] !== "]")
            current += pattern[++i];
          i++;
          template.push({ type: "literal", content: current || "[" });
        } else {
          current += currentChar;
          while (i + 1 < pattern.length && !tokens.has(pattern[i + 1]) && pattern[i + 1] !== "[")
            current += pattern[++i];
          template.push({ type: "literal", content: current });
        }
      }
      return template;
    }
    static resolveDate(time) {
      return time instanceof Date ? time : new Date(time);
    }
  };
  __name(Timestamp, "Timestamp");
  return __toCommonJS(src_exports);
})();
/**
 * Split a string by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @param char The character to split with
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
/**
 * Split a text by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
//# sourceMappingURL=index.global.js.map