{"version":3,"sources":["../src/index.ts","../src/lib/builders/MessageBuilder.ts","../src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts","../src/lib/type-guards.ts","../src/lib/MessagePrompter/strategies/MessagePrompterConfirmStrategy.ts","../src/lib/MessagePrompter/strategies/MessagePrompterMessageStrategy.ts","../src/lib/MessagePrompter/strategies/MessagePrompterNumberStrategy.ts","../src/lib/MessagePrompter/strategies/MessagePrompterReactionStrategy.ts","../src/lib/MessagePrompter/MessagePrompter.ts","../src/lib/PaginatedMessages/LazyPaginatedMessage.ts","../src/lib/PaginatedMessages/PaginatedMessage.ts","../src/lib/PaginatedMessages/utils.ts","../src/lib/PaginatedMessages/PaginatedFieldMessageEmbed.ts","../src/lib/PaginatedMessages/PaginatedMessageEmbedFields.ts","../src/lib/utilities.ts"],"sourcesContent":["export * from '@sapphire/discord-utilities';\nexport * from './lib/builders/MessageBuilder';\nexport * from './lib/MessagePrompter';\nexport * from './lib/PaginatedMessages';\nexport * from './lib/type-guards';\nexport * from './lib/utilities';\nexport * from './lib/utility-types';\n","import type { MessageOptions } from 'discord.js';\n\nexport type MessageBuilderFileResolvable = NonNullable<MessageOptions['files']>[number];\nexport type MessageBuilderResolvable = Omit<MessageOptions, 'embed' | 'disableMentions' | 'reply'> & { embeds?: MessageOptions['embeds'] };\n\n/**\n * A message builder class, it implements the {@link MessageOptions} interface.\n */\nexport class MessageBuilder implements MessageOptions {\n\t/**\n\t * Whether or not the message should be spoken aloud.\n\t * @default false\n\t */\n\tpublic tts?: MessageOptions['tts'];\n\n\t/**\n\t * The nonce for the message.\n\t * @default ''\n\t */\n\tpublic nonce?: MessageOptions['nonce'];\n\n\t/**\n\t * The content for the message. If set to undefined and the builder is used to edit, the content will not be\n\t * replaced.\n\t */\n\tpublic content?: MessageOptions['content'];\n\n\t/**\n\t * The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be replaced.\n\t * @remark There is a maximum of 10 embeds in 1 message\n\t */\n\tpublic embeds?: MessageOptions['embeds'];\n\n\t/**\n\t * Which mentions should be parsed from the message content.\n\t */\n\tpublic allowedMentions?: MessageOptions['allowedMentions'];\n\n\t/**\n\t * Files to send with the message. This should not be set when editing a message, as Discord does not support\n\t * editing file attachments.\n\t */\n\tpublic files?: MessageOptions['files'];\n\n\tpublic constructor(options?: MessageBuilderResolvable) {\n\t\tthis.tts = options?.tts ?? MessageBuilder.defaults.tts;\n\t\tthis.nonce = options?.nonce ?? MessageBuilder.defaults.nonce;\n\t\tthis.content = options?.content ?? MessageBuilder.defaults.content;\n\t\tthis.embeds = options?.embeds ?? MessageBuilder.defaults.embeds;\n\t\tthis.allowedMentions = options?.allowedMentions ?? MessageBuilder.defaults.allowedMentions;\n\t\tthis.files = options?.files ?? MessageBuilder.defaults.files;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.tts} field.\n\t * @param tts Whether or not the message should be spoken aloud.\n\t */\n\tpublic setTTS(tts?: boolean): this {\n\t\tthis.tts = tts;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.nonce} field.\n\t * @param nonce The nonce for the message.\n\t */\n\tpublic setNonce(nonce?: string): this {\n\t\tthis.nonce = nonce;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.content} field.\n\t * @param content The content for the message. If set to undefined and the builder is used to edit, the content will\n\t * not be replaced.\n\t */\n\tpublic setContent(content?: string): this {\n\t\tthis.content = content;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.embed} field.\n\t * @param embeds The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be\n\t * replaced. There is a maximum of 10 embeds per message\n\t * @remark When providing more than 10 embeds, the array will automatically be sliced down to the first 10.\n\t */\n\tpublic setEmbeds(embeds?: MessageOptions['embeds']): this {\n\t\t// Ensure no more than 10 embeds are ever set\n\t\tif (embeds && embeds.length > 10) {\n\t\t\tembeds = embeds.slice(0, 10);\n\t\t}\n\n\t\tthis.embeds = embeds;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.allowedMentions} field.\n\t * @param allowedMentions Which mentions should be parsed from the message content.\n\t */\n\tpublic setAllowedMentions(allowedMentions?: MessageOptions['allowedMentions']): this {\n\t\tthis.allowedMentions = allowedMentions;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a new value for the {@link MessageBuilder.files} field array.\n\t * @param file The file to add to the {@link MessageBuilder.files} field array.\n\t */\n\tpublic addFile(file: MessageBuilderFileResolvable): this {\n\t\tthis.files = this.files?.concat(file) ?? [file];\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets a single value for the {@link MessageBuilder.files} field array.\n\t * @param file The file to send with the message. This should not be set when editing a message, as Discord does not\n\t * support editing file attachments.\n\t */\n\tpublic setFile(file: MessageBuilderFileResolvable): this {\n\t\tthis.files = [file];\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the value for the {@link MessageBuilder.files} field.\n\t * @param files The files to send with the message. This should not be set when editing a message, as Discord does\n\t * not support editing file attachments.\n\t */\n\tpublic setFiles(files?: MessageBuilderFileResolvable[]): this {\n\t\tthis.files = files;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The default values for all MessageBuilder instances.\n\t */\n\tpublic static defaults: MessageBuilderResolvable = {};\n}\n","import { Awaitable, isNullish } from '@sapphire/utilities';\nimport type { CollectorFilter, CollectorOptions, EmojiIdentifierResolvable, Message, MessageReaction, User } from 'discord.js';\nimport { isTextBasedChannel } from '../../type-guards';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from '../constants';\nimport type { IMessagePrompterExplicitReturnBase } from '../ExplicitReturnTypes';\nimport type { IMessagePrompterStrategyOptions } from '../strategyOptions';\n\nexport abstract class MessagePrompterBaseStrategy {\n\t/**\n\t * The type of strategy that was used\n\t */\n\tpublic type: string;\n\n\t/**\n\t * The timeout that was used in the collector\n\t */\n\tpublic timeout: number;\n\n\t/**\n\t * Whether to return an explicit object with data, or the strategies' default\n\t */\n\tpublic explicitReturn: boolean;\n\n\t/**\n\t * The message that has been sent in {@link MessagePrompter.run}\n\t */\n\tpublic appliedMessage: Message | null = null;\n\n\t/**\n\t * The message that will be sent in {@link MessagePrompter.run}\n\t */\n\tpublic message: MessagePrompterMessage;\n\n\t/**\n\t * The message the bot will edit to send its prompt in {@link MessagePrompter.run}\n\t */\n\tpublic editMessage: Message | undefined;\n\n\t/**\n\t * Constructor for the {@link MessagePrompterBaseStrategy} class\n\t * @param messagePrompter The used instance of {@link MessagePrompter}\n\t * @param options Overrideable options if needed.\n\t */\n\tpublic constructor(type: string, message: MessagePrompterMessage, options?: IMessagePrompterStrategyOptions) {\n\t\tthis.type = type;\n\t\tthis.timeout = options?.timeout ?? MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1000;\n\t\tthis.explicitReturn = options?.explicitReturn ?? MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;\n\t\tthis.editMessage = options?.editMessage ?? MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? undefined;\n\t\tthis.message = message;\n\t}\n\n\tpublic abstract run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<unknown[]>): Awaitable<unknown>;\n\n\tprotected async collectReactions(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<[MessageReaction, User]>,\n\t\treactions: string[] | EmojiIdentifierResolvable[]\n\t): Promise<IMessagePrompterExplicitReturnBase> {\n\t\tif (isTextBasedChannel(channel)) {\n\t\t\tif (!isNullish(this.editMessage) && this.editMessage.editable) {\n\t\t\t\tthis.appliedMessage = await this.editMessage.edit(this.message);\n\t\t\t} else {\n\t\t\t\tthis.appliedMessage = await channel.send(this.message);\n\t\t\t}\n\n\t\t\tconst collector = this.appliedMessage.createReactionCollector({\n\t\t\t\t...this.createReactionPromptFilter(reactions, authorOrFilter),\n\t\t\t\tmax: 1,\n\t\t\t\ttime: this.timeout\n\t\t\t});\n\n\t\t\tlet resolved = false;\n\t\t\tconst collected: Promise<MessageReaction> = new Promise<MessageReaction>((resolve, reject) => {\n\t\t\t\tcollector.on('collect', (r) => {\n\t\t\t\t\tresolve(r);\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tcollector.stop();\n\t\t\t\t});\n\n\t\t\t\tcollector.on('end', (collected) => {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tif (!collected.size) reject(new Error('Collector has ended'));\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfor (const reaction of reactions) {\n\t\t\t\tif (resolved) break;\n\n\t\t\t\tawait this.appliedMessage.react(reaction);\n\t\t\t}\n\n\t\t\tconst firstReaction = await collected;\n\t\t\tconst emoji = firstReaction?.emoji;\n\n\t\t\tconst reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);\n\n\t\t\treturn {\n\t\t\t\temoji,\n\t\t\t\treaction,\n\t\t\t\tstrategy: this,\n\t\t\t\tappliedMessage: this.appliedMessage,\n\t\t\t\tmessage: this.message\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error('A channel was provided to which I am not able to send messages');\n\t}\n\n\t/**\n\t * Creates a filter for the collector to filter on\n\t * @return The filter for awaitReactions function\n\t */\n\tprotected createReactionPromptFilter(\n\t\treactions: string[] | EmojiIdentifierResolvable[],\n\t\tauthorOrFilter: User | CollectorFilter<[MessageReaction, User]>\n\t): CollectorOptions<[MessageReaction, User]> {\n\t\treturn {\n\t\t\tfilter: async (reaction: MessageReaction, user: User) =>\n\t\t\t\treactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? '') &&\n\t\t\t\t(typeof authorOrFilter === 'function' ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) &&\n\t\t\t\t!user.bot\n\t\t};\n\t}\n\n\t/**\n\t * The default strategy options\n\t */\n\tpublic static defaultStrategyOptions: IMessagePrompterStrategyOptions = {\n\t\ttimeout: 10 * 1000,\n\t\texplicitReturn: false,\n\t\teditMessage: undefined\n\t};\n}\n","import { isNullish, Nullish } from '@sapphire/utilities';\nimport type { APIMessage } from 'discord-api-types/v9';\nimport {\n\tMessage,\n\ttype BaseGuildVoiceChannel,\n\ttype CategoryChannel,\n\ttype Channel,\n\ttype DMChannel,\n\ttype NewsChannel,\n\ttype PartialDMChannel,\n\ttype PartialGroupDMChannel,\n\ttype StageChannel,\n\ttype StoreChannel,\n\ttype TextChannel,\n\ttype ThreadChannel,\n\ttype VoiceChannel\n} from 'discord.js';\nimport type { ChannelTypes, GuildTextBasedChannelTypes, NonThreadGuildTextBasedChannelTypes, TextBasedChannelTypes } from './utility-types';\n\n/**\n * Checks whether a given channel is a {@link CategoryChannel}\n * @param channel The channel to check\n */\nexport function isCategoryChannel(channel: ChannelTypes | Nullish): channel is CategoryChannel {\n\treturn channel?.type === 'GUILD_CATEGORY';\n}\n\n/**\n * Checks whether a given channel is a {@link DMChannel}\n * @param channel The channel to check\n */\nexport function isDMChannel(channel: ChannelTypes | Nullish): channel is DMChannel | PartialDMChannel {\n\treturn channel?.type === 'DM';\n}\n\n/**\n * Checks whether a given channel is a {@link PartialGroupDMChannel}\n * @param channel The channel to check\n */\nexport function isGroupChannel(channel: Channel | PartialDMChannel | Nullish): channel is PartialGroupDMChannel {\n\treturn channel?.type === 'GROUP_DM';\n}\n\n/**\n * Checks if a channel comes from a guild.\n * @param channel The channel to check\n * @returns Whether or not the channel is guild-based.\n */\nexport function isGuildBasedChannel(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes {\n\treturn channel?.type !== 'DM';\n}\n\n/**\n * Checks whether or not a channel comes from a guild.\n * @remark As opposed to {@link isGuildBasedChannel} this checks if there is `guild` property on the channel.\n * @param channel The channel to check.\n * @returns Whether or not the channel is guild-based.\n */\nexport function isGuildBasedChannelByGuildKey(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes {\n\treturn Reflect.has(channel ?? {}, 'guild');\n}\n\n/**\n * Checks whether a given channel is a {@link NewsChannel}.\n * @param channel The channel to check.\n */\nexport function isNewsChannel(channel: ChannelTypes | Nullish): channel is NewsChannel {\n\treturn channel?.type === 'GUILD_NEWS';\n}\n\n/**\n * Checks whether a given channel is a {@link StoreChannel}\n * @param channel The channel to check\n */\nexport function isStoreChannel(channel: ChannelTypes | Nullish): channel is StoreChannel {\n\treturn channel?.type === 'GUILD_STORE';\n}\n\n/**\n * Checks whether a given channel is a {@link TextChannel}.\n * @param channel The channel to check.\n */\nexport function isTextChannel(channel: ChannelTypes | Nullish): channel is TextChannel {\n\treturn channel?.type === 'GUILD_TEXT';\n}\n\n/**\n * Checks whether a given channel is a {@link VoiceChannel}\n * @param channel The channel to check\n */\nexport function isVoiceChannel(channel: ChannelTypes | Nullish): channel is VoiceChannel {\n\treturn channel?.type === 'GUILD_VOICE';\n}\n\n/**\n * Checks whether a given channel is a {@link StageChannel}\n * @param channel The channel to check\n */\nexport function isStageChannel(channel: ChannelTypes | Nullish): channel is StageChannel {\n\treturn channel?.type === 'GUILD_STAGE_VOICE';\n}\n\n/**\n * Checks whether a given channel is a {@link ThreadChannel}\n * @param channel The channel to check.\n */\nexport function isThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel {\n\treturn channel?.isThread() ?? false;\n}\n\n/**\n * Checks whether a given channel is a News {@link ThreadChannel}\n * @param channel The channel to check.\n */\nexport function isNewsThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel {\n\treturn channel?.type === 'GUILD_NEWS_THREAD';\n}\n\n/**\n * Checks whether a given channel is a Public {@link ThreadChannel}\n * @param channel The channel to check.\n */\nexport function isPublicThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel {\n\treturn channel?.type === 'GUILD_PUBLIC_THREAD';\n}\n\n/**\n * Checks whether a given channel is a Private {@link ThreadChannel}\n * @param channel The channel to check.\n */\nexport function isPrivateThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel {\n\treturn channel?.type === 'GUILD_PRIVATE_THREAD';\n}\n\n/**\n * Checks whether a given channel is a {@link TextBasedChannelTypes}. This means it has a `send` method.\n * @param channel The channel to check.\n */\nexport function isTextBasedChannel(channel: ChannelTypes | Nullish): channel is TextBasedChannelTypes {\n\tif (isNullish(channel)) return false;\n\n\treturn !isNullish((channel as TextBasedChannelTypes).send);\n}\n\n/**\n * Checks whether a given channel is a {@link BaseGuildVoiceChannel}.\n * @param channel: The channel to checl.\n */\nexport function isVoiceBasedChannel(channel: Channel | Nullish): channel is BaseGuildVoiceChannel {\n\tif (isNullish(channel)) return false;\n\n\treturn channel.isVoice();\n}\n\n/**\n * Checks whether a given channel allows NSFW content or not\n * @param channel The channel to check.\n */\nexport function isNsfwChannel(channel: ChannelTypes | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\n\tswitch (channel.type) {\n\t\tcase 'DM':\n\t\tcase 'GROUP_DM':\n\t\tcase 'GUILD_CATEGORY':\n\t\tcase 'GUILD_STAGE_VOICE':\n\t\tcase 'GUILD_STORE':\n\t\tcase 'GUILD_VOICE':\n\t\tcase 'UNKNOWN':\n\t\t\treturn false;\n\t\tcase 'GUILD_NEWS':\n\t\tcase 'GUILD_TEXT':\n\t\t\treturn (channel as NonThreadGuildTextBasedChannelTypes).nsfw;\n\t\tcase 'GUILD_NEWS_THREAD':\n\t\tcase 'GUILD_PRIVATE_THREAD':\n\t\tcase 'GUILD_PUBLIC_THREAD':\n\t\t\treturn Boolean((channel as ThreadChannel).parent?.nsfw);\n\t}\n}\n\n/**\n * Checks whether a given message is an instance of {@link Message}, and not {@link APIMessage}\n * @param message The message to check\n * @returns `true` if the message is an instance of `Message`, false otherwise.\n */\nexport function isMessageInstance(message: APIMessage | Message): message is Message {\n\treturn message instanceof Message;\n}\n","import type { CollectorFilter, EmojiResolvable, MessageReaction, User } from 'discord.js';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from '../constants';\nimport type { IMessagePrompterExplicitConfirmReturn } from '../ExplicitReturnTypes';\nimport type { IMessagePrompterConfirmStrategyOptions } from '../strategyOptions';\nimport { MessagePrompterBaseStrategy } from './MessagePrompterBaseStrategy';\n\nexport class MessagePrompterConfirmStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterConfirmStrategyOptions {\n\t/**\n\t * The confirm emoji used\n\t */\n\tpublic confirmEmoji: string | EmojiResolvable;\n\n\t/**\n\t * The cancel emoji used\n\t */\n\tpublic cancelEmoji: string | EmojiResolvable;\n\n\t/**\n\t * Constructor for the {@link MessagePrompterBaseStrategy} class\n\t * @param message The message to be sent {@link MessagePrompter}\n\t * @param options Overrideable options if needed.\n\t */\n\tpublic constructor(message: MessagePrompterMessage, options?: IMessagePrompterConfirmStrategyOptions) {\n\t\tsuper('confirm', message, options);\n\n\t\tthis.confirmEmoji = options?.confirmEmoji ?? MessagePrompterConfirmStrategy.confirmEmoji;\n\t\tthis.cancelEmoji = options?.cancelEmoji ?? MessagePrompterConfirmStrategy.cancelEmoji;\n\t}\n\n\t/**\n\t * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals confirm.\n\t * The handler will wait for one (1) reaction.\n\t * @param channel The channel to use.\n\t * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.\n\t * @returns A promise that resolves to a boolean denoting the value of the input (`true` for yes, `false` for no).\n\t */\n\tpublic override async run(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<[MessageReaction, User]>\n\t): Promise<IMessagePrompterExplicitConfirmReturn | boolean> {\n\t\tconst response = await this.collectReactions(channel, authorOrFilter, [this.confirmEmoji, this.cancelEmoji]);\n\n\t\tconst confirmed = (response?.emoji?.id ?? response?.emoji?.name) === this.confirmEmoji;\n\n\t\t// prettier-ignore\n\t\treturn this.explicitReturn ? { ...response, confirmed } : confirmed;\n\t}\n\n\t/**\n\t * The default confirm emoji used for {@link MessagePrompterConfirmStrategy}\n\t */\n\tpublic static confirmEmoji: string | EmojiResolvable = 'üáæ';\n\n\t/**\n\t * The default cancel emoji used for {@link MessagePrompterConfirmStrategy}\n\t */\n\tpublic static cancelEmoji: string | EmojiResolvable = 'üá≥';\n}\n","import { isNullish } from '@sapphire/utilities';\nimport type { CollectorFilter, CollectorOptions, Message, User } from 'discord.js';\nimport { isTextBasedChannel } from '../../type-guards';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from '../constants';\nimport type { IMessagePrompterExplicitMessageReturn } from '../ExplicitReturnTypes';\nimport type { IMessagePrompterStrategyOptions } from '../strategyOptions';\nimport { MessagePrompterBaseStrategy } from './MessagePrompterBaseStrategy';\n\nexport class MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterStrategyOptions {\n\t/**\n\t * Constructor for the {@link MessagePrompterBaseStrategy} class\n\t * @param messagePrompter The used instance of {@link MessagePrompter}\n\t * @param options Overrideable options if needed.\n\t */\n\tpublic constructor(message: MessagePrompterMessage, options: IMessagePrompterStrategyOptions) {\n\t\tsuper('message', message, options);\n\t}\n\n\t/**\n\t * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.\n\t * The handler will wait for one (1) message.\n\t * @param channel The channel to use.\n\t * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.\n\t * @returns A promise that resolves to the message object received.\n\t */\n\tpublic override async run(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<[Message]>\n\t): Promise<IMessagePrompterExplicitMessageReturn | Message> {\n\t\tif (isTextBasedChannel(channel)) {\n\t\t\tif (!isNullish(this.editMessage) && this.editMessage.editable) {\n\t\t\t\tthis.appliedMessage = await this.editMessage.edit(this.message);\n\t\t\t} else {\n\t\t\t\tthis.appliedMessage = await channel.send(this.message);\n\t\t\t}\n\n\t\t\tconst collector = await channel.awaitMessages({\n\t\t\t\t...this.createMessagePromptFilter(authorOrFilter),\n\t\t\t\tmax: 1,\n\t\t\t\ttime: this.timeout,\n\t\t\t\terrors: ['time']\n\t\t\t});\n\t\t\tconst response = collector.first();\n\n\t\t\tif (!response) {\n\t\t\t\tthrow new Error('No messages received');\n\t\t\t}\n\n\t\t\treturn this.explicitReturn\n\t\t\t\t? {\n\t\t\t\t\t\tresponse,\n\t\t\t\t\t\tstrategy: this,\n\t\t\t\t\t\tappliedMessage: this.appliedMessage,\n\t\t\t\t\t\tmessage: this.message\n\t\t\t\t  }\n\t\t\t\t: response;\n\t\t}\n\n\t\tthrow new Error('A channel was provided to which I am not able to send messages');\n\t}\n\n\t/**\n\t * Creates a filter for the collector to filter on\n\t * @return The filter for awaitMessages function\n\t */\n\tprivate createMessagePromptFilter(authorOrFilter: User | CollectorFilter<[Message]>): CollectorOptions<[Message]> {\n\t\treturn {\n\t\t\tfilter: async (message: Message) =>\n\t\t\t\t(typeof authorOrFilter === 'function' ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) &&\n\t\t\t\t!message.author.bot\n\t\t};\n\t}\n}\n","import type { CollectorFilter, EmojiIdentifierResolvable, MessageReaction, User } from 'discord.js';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from '../constants';\nimport type { IMessagePrompterExplicitNumberReturn } from '../ExplicitReturnTypes';\nimport type { IMessagePrompterNumberStrategyOptions } from '../strategyOptions';\nimport { MessagePrompterBaseStrategy } from './MessagePrompterBaseStrategy';\n\nexport class MessagePrompterNumberStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterNumberStrategyOptions {\n\t/**\n\t * The available number emojis\n\t */\n\tpublic numberEmojis: EmojiIdentifierResolvable[];\n\t/**\n\t * The available number emojis\n\t */\n\tpublic start: number;\n\t/**\n\t * The available number emojis\n\t */\n\tpublic end: number;\n\n\t/**\n\t * Constructor for the {@link MessagePrompterBaseStrategy} class\n\t * @param messagePrompter The used instance of {@link MessagePrompter}\n\t * @param options Overrideable options if needed.\n\t */\n\tpublic constructor(message: MessagePrompterMessage, options: IMessagePrompterNumberStrategyOptions) {\n\t\tsuper('number', message, options);\n\n\t\tthis.numberEmojis = options?.numberEmojis ?? MessagePrompterNumberStrategy.numberEmojis;\n\t\tthis.start = options?.start ?? 0;\n\t\tthis.end = options?.end ?? 10;\n\t}\n\n\t/**\n\t * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals number.\n\t * The handler will wait for one (1) reaction.\n\t * @param channel The channel to use.\n\t * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.\n\t * @returns A promise that resolves to the selected number within the range.\n\t */\n\tpublic async run(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<[MessageReaction, User]>\n\t): Promise<IMessagePrompterExplicitNumberReturn | number> {\n\t\t// 0 and 10 are the maximum available emojis as a number\n\t\tif (this.start < 0) throw new TypeError('Starting number cannot be less than 0.');\n\t\tif (this.end > 10) throw new TypeError('Ending number cannot be more than 10.');\n\n\t\tconst numbers = Array.from({ length: this.end - this.start + 1 }, (_, n: number) => n + this.start);\n\t\tconst emojis = this.numberEmojis.slice(this.start, this.end);\n\t\tconst response = await this.collectReactions(channel, authorOrFilter, emojis);\n\n\t\tconst emojiIndex = emojis.findIndex((emoji) => (response?.emoji?.id ?? response?.emoji?.name) === emoji);\n\t\tconst number = numbers[emojiIndex];\n\n\t\t// prettier-ignore\n\t\treturn this.explicitReturn ? { ...response, number } : number;\n\t}\n\n\t/**\n\t * The default available number emojis\n\t */\n\tpublic static numberEmojis = ['0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü'];\n}\n","import type { CollectorFilter, EmojiIdentifierResolvable, EmojiResolvable, MessageReaction, User } from 'discord.js';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from '../constants';\nimport type { IMessagePrompterExplicitReturnBase } from '../ExplicitReturnTypes';\nimport type { IMessagePrompterReactionStrategyOptions } from '../strategyOptions';\nimport { MessagePrompterBaseStrategy } from './MessagePrompterBaseStrategy';\n\nexport class MessagePrompterReactionStrategy extends MessagePrompterBaseStrategy implements MessagePrompterReactionStrategy {\n\t/**\n\t * The emojis used\n\t */\n\tpublic reactions: EmojiIdentifierResolvable[];\n\n\t/**\n\t * Constructor for the {@link MessagePrompterReactionStrategy} class\n\t * @param messagePrompter The used instance of {@link MessagePrompter}\n\t * @param options Overrideable options if needed.\n\t */\n\tpublic constructor(message: MessagePrompterMessage, options: IMessagePrompterReactionStrategyOptions) {\n\t\tsuper('reactions', message, options);\n\n\t\tthis.reactions = options?.reactions;\n\t}\n\n\t/**\n\t * This executes the {@link MessagePrompterReactionStrategy} and sends the message.\n\t * The handler will wait for one (1) reaction.\n\t * @param channel The channel to use.\n\t * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.\n\t * @returns A promise that resolves to the reaction object.\n\t */\n\tpublic async run(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<[MessageReaction, User]>\n\t): Promise<IMessagePrompterExplicitReturnBase | string | EmojiResolvable> {\n\t\tif (!this.reactions?.length) throw new TypeError('There are no reactions provided.');\n\n\t\tconst response = await this.collectReactions(channel, authorOrFilter, this.reactions);\n\n\t\treturn this.explicitReturn ? response : response.reaction ?? response;\n\t}\n}\n","import type { Ctor } from '@sapphire/utilities';\nimport type { CollectorFilter, EmojiResolvable, Message, MessageReaction, User } from 'discord.js';\nimport type { MessagePrompterChannelTypes, MessagePrompterMessage } from './constants';\nimport type {\n\tIMessagePrompterExplicitConfirmReturn,\n\tIMessagePrompterExplicitMessageReturn,\n\tIMessagePrompterExplicitNumberReturn,\n\tIMessagePrompterExplicitReturnBase\n} from './ExplicitReturnTypes';\nimport { MessagePrompterBaseStrategy } from './strategies/MessagePrompterBaseStrategy';\nimport { MessagePrompterConfirmStrategy } from './strategies/MessagePrompterConfirmStrategy';\nimport { MessagePrompterMessageStrategy } from './strategies/MessagePrompterMessageStrategy';\nimport { MessagePrompterNumberStrategy } from './strategies/MessagePrompterNumberStrategy';\nimport { MessagePrompterReactionStrategy } from './strategies/MessagePrompterReactionStrategy';\nimport type {\n\tIMessagePrompterConfirmStrategyOptions,\n\tIMessagePrompterNumberStrategyOptions,\n\tIMessagePrompterReactionStrategyOptions,\n\tIMessagePrompterStrategyOptions\n} from './strategyOptions';\n\nexport interface StrategyReturns {\n\tconfirm: IMessagePrompterExplicitConfirmReturn | boolean;\n\tmessage: IMessagePrompterExplicitMessageReturn | Message;\n\tnumber: IMessagePrompterExplicitNumberReturn | number;\n\treaction: IMessagePrompterExplicitReturnBase | string | EmojiResolvable;\n}\n\nexport interface StrategyOptions {\n\tconfirm: IMessagePrompterConfirmStrategyOptions;\n\tmessage: IMessagePrompterStrategyOptions;\n\tnumber: IMessagePrompterNumberStrategyOptions;\n\treaction: IMessagePrompterReactionStrategyOptions;\n}\n\nexport interface StrategyFilters {\n\tconfirm: [MessageReaction, User];\n\tmessage: [Message];\n\tnumber: [MessageReaction, User];\n\treaction: [MessageReaction, User];\n}\n\n/**\n * This is a {@link MessagePrompter}, a utility that sends a message, prompting for user input. The prompt can resolve to any kind of input.\n * There are several specifiable types to prompt for user input, and they are as follows:\n * - Confirm\n *   This will send a simple Yes/No prompt, using reactions.\n * - Number\n *   This will prompt for an integer. By default it will be a number between 0 and 10 (inclusive), however you can also specify your own custom range (inclusive).\n * - Reactions\n *   This can be any kind of reaction emoji that Discord supports, and as many as you want. This type will return that reaction instead of a boolean.\n * - Message\n *   This will prompt the user and require a response in the form of a message. This can be helpful if you require a user to upload an image for example, or give text input.\n *\n * You must either use this class directly or extend it.\n *\n * {@link MessagePrompter} uses reactions to prompt for a yes/no answer and returns it.\n * You can modify the confirm and cancel reaction used for each message, or use the {@link MessagePrompter.defaultPrompts}.\n * {@link MessagePrompter.defaultPrompts} is also static so you can modify these directly.\n *\n * @example\n * ```typescript\n * const { MessagePrompter } = require('@sapphire/discord.js-utilities');\n *\n * const handler = new MessagePrompter('Are you sure you want to continue?');\n * const result = await handler.run(channel, author);\n * ```\n *\n * @example\n * ```typescript\n * const { MessagePrompter } = require('@sapphire/discord.js-utilities');\n *\n * const handler = new MessagePrompter('Choose a number between 5 and 10?', 'number', {\n * \t\tstart: 5,\n * \t\tend: 10\n * });\n * const result = await handler.run(channel, author);\n * ```\n *\n * @example\n * ```typescript\n * const { MessagePrompter } = require('@sapphire/discord.js-utilities');\n *\n * const handler = new MessagePrompter('Are you happy or sad?', 'reaction', {\n * \t\treactions: ['üôÇ', 'üôÅ']\n * });\n * const result = await handler.run(channel, author);\n * ```\n *\n * @example\n * ```typescript\n * const { MessagePrompter } = require('@sapphire/discord.js-utilities');\n *\n * const handler = new MessagePrompter('Do you love me?', 'message');\n * const result = await handler.run(channel, author);\n * ```\n */\nexport class MessagePrompter<S extends keyof StrategyReturns = 'confirm'> {\n\t/**\n\t * The strategy used in {@link MessagePrompter.run}\n\t */\n\tpublic strategy: MessagePrompterBaseStrategy;\n\n\t/**\n\t * Constructor for the {@link MessagePrompter} class\n\t * @param message The message to send.\n\t * @param strategy The strategy name or Instance to use\n\t * @param strategyOptions The options that are passed to the strategy\n\t */\n\tpublic constructor(\n\t\tmessage: MessagePrompterMessage | MessagePrompterBaseStrategy,\n\t\tstrategy?: S,\n\t\tstrategyOptions?: S extends keyof StrategyOptions ? StrategyOptions[S] : never\n\t) {\n\t\tlet strategyToRun: MessagePrompterBaseStrategy;\n\n\t\tif (message instanceof MessagePrompterBaseStrategy) {\n\t\t\tstrategyToRun = message;\n\t\t} else {\n\t\t\tconst mapStrategy = MessagePrompter.strategies.get(strategy ?? MessagePrompter.defaultStrategy);\n\n\t\t\tif (!mapStrategy) {\n\t\t\t\tthrow new Error('No strategy provided');\n\t\t\t}\n\n\t\t\tstrategyToRun = new mapStrategy(message, strategyOptions);\n\t\t}\n\n\t\tthis.strategy = strategyToRun;\n\t}\n\n\t/**\n\t * This executes the {@link MessagePrompter} and sends the message.\n\t * @param channel The channel to use.\n\t * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.\n\t */\n\tpublic run<Filter extends S extends keyof StrategyFilters ? StrategyFilters[S] : unknown[]>(\n\t\tchannel: MessagePrompterChannelTypes,\n\t\tauthorOrFilter: User | CollectorFilter<Filter>\n\t): S extends keyof StrategyReturns ? Promise<StrategyReturns[S]> : never {\n\t\treturn this.strategy.run(channel, authorOrFilter as User | CollectorFilter<unknown[]>) as S extends keyof StrategyReturns\n\t\t\t? Promise<StrategyReturns[S]>\n\t\t\t: never;\n\t}\n\n\t/**\n\t * The available strategies\n\t */\n\tpublic static strategies: Map<\n\t\tkeyof StrategyReturns,\n\t\tCtor<\n\t\t\t| ConstructorParameters<typeof MessagePrompterConfirmStrategy>\n\t\t\t| ConstructorParameters<typeof MessagePrompterNumberStrategy>\n\t\t\t| ConstructorParameters<typeof MessagePrompterReactionStrategy>\n\t\t\t| ConstructorParameters<typeof MessagePrompterMessageStrategy>,\n\t\t\tMessagePrompterConfirmStrategy | MessagePrompterNumberStrategy | MessagePrompterReactionStrategy | MessagePrompterMessageStrategy\n\t\t>\n\t\t// @ts-expect-error 2322\n\t> = new Map([\n\t\t['confirm', MessagePrompterConfirmStrategy],\n\t\t['number', MessagePrompterNumberStrategy],\n\t\t['reaction', MessagePrompterReactionStrategy],\n\t\t['message', MessagePrompterMessageStrategy]\n\t]);\n\n\t/**\n\t * The default strategy to use\n\t */\n\tpublic static defaultStrategy: keyof StrategyReturns = 'confirm';\n}\n","import { isFunction } from '@sapphire/utilities';\nimport { MessageEmbed } from 'discord.js';\nimport { MessageBuilder } from '../builders/MessageBuilder';\nimport { PaginatedMessage } from './PaginatedMessage';\nimport type { PaginatedMessagePage } from './PaginatedMessageTypes';\n\n/**\n * This is a LazyPaginatedMessage. Instead of resolving all pages that are functions on {@link PaginatedMessage.run} will resolve when requested.\n */\nexport class LazyPaginatedMessage extends PaginatedMessage {\n\t/**\n\t * Only resolves the page corresponding with the handler's current index.\n\t */\n\tpublic override async resolvePagesOnRun(): Promise<void> {\n\t\tawait this.resolvePage(this.index);\n\t}\n\n\t/**\n\t * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.\n\t * @param index The index to resolve. Defaults to handler's current index.\n\t */\n\tpublic override async resolvePage(index: number): Promise<PaginatedMessagePage> {\n\t\tconst promises = [super.resolvePage(index)];\n\t\tif (this.hasPage(index - 1)) promises.push(super.resolvePage(index - 1));\n\t\tif (this.hasPage(index + 1)) promises.push(super.resolvePage(index + 1));\n\n\t\tconst [result] = await Promise.all(promises);\n\t\treturn result;\n\t}\n\n\tpublic override addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this {\n\t\treturn this.addPage(() => (isFunction(builder) ? builder(new MessageBuilder()) : builder));\n\t}\n\n\tpublic override addPageContent(content: string): this {\n\t\treturn this.addPage(() => ({ content }));\n\t}\n\n\tpublic override addPageEmbed(embed: MessageEmbed | ((builder: MessageEmbed) => MessageEmbed)): this {\n\t\treturn this.addPage(() => ({ embeds: typeof embed === 'function' ? [embed(new MessageEmbed())] : [embed] }));\n\t}\n\n\tpublic override addPageEmbeds(\n\t\tembeds:\n\t\t\t| MessageEmbed[]\n\t\t\t| ((\n\t\t\t\t\tembed1: MessageEmbed,\n\t\t\t\t\tembed2: MessageEmbed,\n\t\t\t\t\tembed3: MessageEmbed,\n\t\t\t\t\tembed4: MessageEmbed,\n\t\t\t\t\tembed5: MessageEmbed,\n\t\t\t\t\tembed6: MessageEmbed,\n\t\t\t\t\tembed7: MessageEmbed,\n\t\t\t\t\tembed8: MessageEmbed,\n\t\t\t\t\tembed9: MessageEmbed,\n\t\t\t\t\tembed10: MessageEmbed\n\t\t\t  ) => MessageEmbed[])\n\t): this {\n\t\treturn this.addPage(() => {\n\t\t\tlet processedEmbeds = isFunction(embeds)\n\t\t\t\t? embeds(\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed()\n\t\t\t\t  )\n\t\t\t\t: embeds;\n\n\t\t\tif (processedEmbeds.length > 10) {\n\t\t\t\tprocessedEmbeds = processedEmbeds.slice(0, 10);\n\t\t\t}\n\n\t\t\treturn { embeds: processedEmbeds };\n\t\t});\n\t}\n}\n","import { Time } from '@sapphire/time-utilities';\nimport { deepClone, isFunction, isNullish, isObject } from '@sapphire/utilities';\nimport type { APIMessage } from 'discord-api-types/v9';\nimport {\n\tConstants,\n\tFormatters,\n\tIntents,\n\tInteractionCollector,\n\tMessageButton,\n\tMessageEmbed,\n\tMessageSelectMenu,\n\ttype ButtonInteraction,\n\ttype Collection,\n\ttype CommandInteraction,\n\ttype ContextMenuInteraction,\n\ttype Message,\n\ttype MessageComponentInteraction,\n\ttype MessageOptions,\n\ttype SelectMenuInteraction,\n\ttype Snowflake,\n\ttype TextBasedChannel,\n\ttype User,\n\ttype WebhookEditMessageOptions\n} from 'discord.js';\nimport { MessageBuilder } from '../builders/MessageBuilder';\nimport { isGuildBasedChannel, isMessageInstance } from '../type-guards';\nimport type {\n\tPaginatedMessageAction,\n\tPaginatedMessageEmbedResolvable,\n\tPaginatedMessageMessageOptionsUnion,\n\tPaginatedMessageOptions,\n\tPaginatedMessagePage,\n\tPaginatedMessageSelectMenuOptionsFunction,\n\tPaginatedMessageWrongUserInteractionReplyFunction\n} from './PaginatedMessageTypes';\nimport { actionIsButtonOrMenu, createPartitionedMessageRow, isMessageButtonInteraction, runsOnInteraction, safelyReplyToInteraction } from './utils';\n\n/**\n * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).\n * You must either use this class directly or extend it.\n *\n * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.\n * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.\n *\n * {@link PaginatedMessage} uses {@linkplain https://discord.js.org/#/docs/main/stable/typedef/MessageComponent MessageComponent} buttons that perform the specified action when clicked.\n * You can either use your own actions or the {@link PaginatedMessage.defaultActions}.\n * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.\n *\n * {@link PaginatedMessage} also uses pages via {@linkplain https://discord.js.org/#/docs/main/stable/class/Message Messages}.\n *\n * @example\n * ```typescript\n * const myPaginatedMessage = new PaginatedMessage();\n * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.\n * // For more details see each method's documentation.\n *\n * myPaginatedMessage.addPageEmbed((embed) => {\n *\t\tembed\n *\t\t\t.setColor('#FF0000')\n *\t\t\t.setDescription('example description');\n *\n *\t\treturn embed;\n * });\n *\n * myPaginatedMessage.addPageBuilder((builder) => {\n *\t\tconst embed = new MessageEmbed()\n *\t\t\t.setColor('#FF0000')\n *\t\t\t.setDescription('example description');\n *\n *\t\treturn builder\n *\t\t\t.setContent('example content')\n *\t\t\t.setEmbeds([embed]);\n * });\n *\n * myPaginatedMessage.addPageContent('Example');\n *\n * myPaginatedMessage.run(message)\n * ```\n *\n * @remark You can also provide a MessageEmbed template. This will be applied to every page.\n * If a page itself has an embed then the two will be merged, with the content of\n * the page's embed taking priority over the template.\n *\n * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer\n * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`\n * the resulting footer will be `1/2 - Powered by Sapphire Framework`\n * @example\n * ```typescript\n * const myPaginatedMessage = new PaginatedMessage({\n * \ttemplate: new MessageEmbed().setColor('#FF0000').setFooter('- Powered by Sapphire framework')\n * });\n * ```\n *\n * @remark To utilize actions you can implement IPaginatedMessageAction into a class.\n * @example\n * ```typescript\n * class ForwardAction implements IPaginatedMessageAction {\n *   public id = '‚ñ∂Ô∏è';\n *\n *   public run({ handler }) {\n *     if (handler.index !== handler.pages.length - 1) ++handler.index;\n *   }\n * }\n *\n * // You can also give the object directly.\n *\n * const StopAction: IPaginatedMessageAction = {\n *   customId: 'CustomStopAction',\n *   run: ({ collector }) => {\n *     collector.stop();\n *   }\n * }\n * ```\n */\nexport class PaginatedMessage {\n\t/** The response we send when someone gets into an invalid flow */\n\t#thisMazeWasNotMeantForYouContent = { content: \"This maze wasn't meant for you...what did you do.\" };\n\n\t// #region public class properties\n\t/**\n\t * The pages to be converted to {@link PaginatedMessage.messages}\n\t */\n\tpublic pages: PaginatedMessagePage[];\n\n\t/**\n\t * The response message used to edit on page changes.\n\t */\n\tpublic response: APIMessage | Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction | null = null;\n\n\t/**\n\t * The collector used for handling component interactions.\n\t */\n\tpublic collector: InteractionCollector<MessageComponentInteraction> | null = null;\n\n\t/**\n\t * The pages which were converted from {@link PaginatedMessage.pages}\n\t */\n\tpublic messages: (PaginatedMessagePage | null)[] = [];\n\n\t/**\n\t * The actions which are to be used.\n\t */\n\tpublic actions = new Map<string, PaginatedMessageAction>();\n\n\t/**\n\t * The handler's current page/message index.\n\t */\n\tpublic index = 0;\n\n\t/**\n\t * The amount of milliseconds to idle before the paginator is closed.\n\t * @default 14.5 minutes\n\t * @remark This is to ensure it is a bit before interactions expire.\n\t */\n\tpublic idle = Time.Minute * 14.5;\n\n\t/**\n\t * The template for this {@link PaginatedMessage}.\n\t * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}\n\t */\n\tpublic template: PaginatedMessageMessageOptionsUnion;\n\n\t/**\n\t * Custom text to show in front of the page index in the embed footer.\n\t * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.\n\t * @default ```PaginatedMessage.pageIndexPrefix``` (static property)\n\t */\n\tpublic pageIndexPrefix = PaginatedMessage.pageIndexPrefix;\n\n\t/**\n\t * Custom separator to show after the page index in the embed footer.\n\t * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.\n\t * @default ```PaginatedMessage.embedFooterSeparator``` (static property)\n\t */\n\tpublic embedFooterSeparator = PaginatedMessage.embedFooterSeparator;\n\n\t/**\n\t * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}\n\t * @default ```PaginatedMessage.stopPaginatedMessageCustomIds``` (static property)\n\t */\n\tpublic stopPaginatedMessageCustomIds = PaginatedMessage.stopPaginatedMessageCustomIds;\n\n\t/**\n\t * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client having the `'CHANNEL'` partial.\n\t * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.\n\t *\n\t * @default ```PaginatedMessage.emitPartialDMChannelWarning``` (static property)\n\t */\n\tpublic emitPartialDMChannelWarning = PaginatedMessage.emitPartialDMChannelWarning;\n\n\t// #endregion\n\t// #region protected class properties\n\tprotected paginatedMessageData: Omit<PaginatedMessageMessageOptionsUnion, 'components'> | null = null;\n\n\tprotected selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction = PaginatedMessage.selectMenuOptions;\n\n\tprotected wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction = PaginatedMessage.wrongUserInteractionReply;\n\n\t/**\n\t * Tracks whether a warning was already emitted for this {@link PaginatedMessage}\n\t * concerning the maximum amount of pages in the {@link SelectMenu}.\n\t */\n\tprotected hasEmittedMaxPageWarning = false;\n\n\t/**\n\t * Tracks whether a warning was already emitted for this {@link PaginatedMessage}\n\t * concerning the {@link PaginatedMessage} being called in a `DMChannel`\n\t * without the client having the `'Channel'` partial.\n\t *\n\t * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.\n\t */\n\tprotected hasEmittedPartialDMChannelWarning = false;\n\n\t// #endregion\n\n\t/**\n\t * Constructor for the {@link PaginatedMessage} class\n\t * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class\n\t */\n\tpublic constructor({\n\t\tpages,\n\t\tactions,\n\t\ttemplate,\n\t\tpageIndexPrefix,\n\t\tembedFooterSeparator,\n\t\tpaginatedMessageData = null\n\t}: PaginatedMessageOptions = {}) {\n\t\tthis.pages = pages ?? [];\n\n\t\tfor (const page of this.pages) {\n\t\t\tif (isFunction(page) || isObject(page)) {\n\t\t\t\tthis.messages.push(page);\n\t\t\t}\n\t\t}\n\n\t\tfor (const action of actions ?? this.constructor.defaultActions) {\n\t\t\tif (actionIsButtonOrMenu(action)) {\n\t\t\t\tthis.actions.set(action.customId, action);\n\t\t\t} else {\n\t\t\t\tthis.actions.set(action.url, action);\n\t\t\t}\n\t\t}\n\n\t\tthis.template = PaginatedMessage.resolveTemplate(template);\n\t\tthis.pageIndexPrefix = pageIndexPrefix ?? PaginatedMessage.pageIndexPrefix;\n\t\tthis.embedFooterSeparator = embedFooterSeparator ?? PaginatedMessage.embedFooterSeparator;\n\t\tthis.paginatedMessageData = paginatedMessageData;\n\t}\n\n\t// #region property setters\n\n\t/**\n\t * Sets the {@link PaginatedMessage.selectMenuOptions} for this instance of {@link PaginatedMessage}.\n\t * This will only apply to this one instance and no others.\n\t * @param newOptions The new options generator to set\n\t * @returns The current instance of {@link PaginatedMessage}\n\t */\n\tpublic setSelectMenuOptions(newOptions: PaginatedMessageSelectMenuOptionsFunction): this {\n\t\tthis.selectMenuOptions = newOptions;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the {@link PaginatedMessage.wrongUserInteractionReply} for this instance of {@link PaginatedMessage}.\n\t * This will only apply to this one instance and no others.\n\t * @param wrongUserInteractionReply The new `wrongUserInteractionReply` to set\n\t * @returns The current instance of {@link PaginatedMessage}\n\t */\n\tpublic setWrongUserInteractionReply(wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction): this {\n\t\tthis.wrongUserInteractionReply = wrongUserInteractionReply;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the {@link PaginatedMessage.stopPaginatedMessageCustomIds} for this instance of {@link PaginatedMessage}.\n\t * This will only apply to this one instance and no others.\n\t * @param stopPaginatedMessageCustomIds The new `stopPaginatedMessageCustomIds` to set\n\t * @returns The current instance of {@link PaginatedMessage}\n\t */\n\tpublic setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds: string[]): this {\n\t\tthis.stopPaginatedMessageCustomIds = stopPaginatedMessageCustomIds;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the {@link PaginatedMessage.emitPartialDMChannelWarning} for this instance of {@link PaginatedMessage}.\n\t * This will only apply to this one instance and no others.\n\t * @param emitPartialDMChannelWarning The new `emitPartialDMChannelWarning` to set\n\t * @returns The current instance of {@link PaginatedMessage}\n\t */\n\tpublic setEmitPartialDMChannelWarning(emitPartialDMChannelWarning: boolean): this {\n\t\tthis.emitPartialDMChannelWarning = emitPartialDMChannelWarning;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the handler's current page/message index.\n\t * @param index The number to set the index to.\n\t */\n\tpublic setIndex(index: number): this {\n\t\tthis.index = index;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of time to idle before the paginator is closed.\n\t * @param idle The number to set the idle to.\n\t */\n\tpublic setIdle(idle: number): this {\n\t\tthis.idle = idle;\n\t\treturn this;\n\t}\n\n\t// #endregion\n\t// #region actions related methods\n\n\t/**\n\t * Clears all current actions and sets them. The order given is the order they will be used.\n\t * @param actions The actions to set. This can be either a Button, Link Button, or Select Menu.\n\t * @param includeDefaultActions Whether to merge in the {@link PaginatedMessage.defaultActions} when setting the actions.\n\t * If you set this to true then you do not need to manually add `...PaginatedMessage.defaultActions` as seen in the first example.\n\t * The default value is `false` for backwards compatibility within the current major version.\n\t *\n\t * @remark You can retrieve the default actions for the regular pagination\n\t * @example\n\t * ```typescript\n\t * const display = new PaginatedMessage();\n\t *\n\t * display.setActions([\n\t *   ...PaginatedMessage.defaultActions,\n\t * ])\n\t * ```\n\t *\n\t * @remark You can add custom Message Buttons by providing `style`, `customId`, `type`, `run` and at least one of `label` or `emoji`.\n\t * @example\n\t * ```typescript\n\t * const display = new PaginatedMessage();\n\t *\n\t * display.setActions([\n\t *   {\n\t *     style: 'PRIMARY',\n\t *     label: 'My Button',\n\t *     customId: 'custom_button',\n\t *     type: Constants.MessageComponentTypes.BUTTON,\n\t *     run: (context) => console.log(context)\n\t *   }\n\t * ], true);\n\t * ```\n\t *\n\t * @remark You can add custom Message **Link** Buttons by providing `style`, `url`, `type`, and at least one of `label` or `emoji`.\n\t * @example\n\t * ```typescript\n\t * const display = new PaginatedMessage();\n\t *\n\t * display.setActions([\n\t *   {\n\t *     style: 'LINK',\n\t *     label: 'Sapphire Website',\n\t *     emoji: 'üî∑',\n\t *     url: 'https://sapphirejs.dev',\n\t *     type: Constants.MessageComponentTypes.BUTTON\n\t *   }\n\t * ], true);\n\t * ```\n\t *\n\t * @remark You can add custom Select Menus by providing `customId`, `type`, and `run`.\n\t * @example\n\t * ```typescript\n\t * const display = new PaginatedMessage();\n\t *\n\t * display.setActions([\n\t *   {\n\t *     customId: 'custom_menu',\n\t *     type: Constants.MessageComponentTypes.SELECT_MENU,\n\t *     run: (context) => console.log(context) // Do something here\n\t *   }\n\t * ], true);\n\t * ```\n\t */\n\tpublic setActions(actions: PaginatedMessageAction[], includeDefaultActions = false): this {\n\t\tthis.actions.clear();\n\t\treturn this.addActions([...(includeDefaultActions ? PaginatedMessage.defaultActions : []), ...actions]);\n\t}\n\n\t/**\n\t * Adds actions to the existing ones. The order given is the order they will be used.\n\t * @param actions The actions to add.\n\t * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.\n\t */\n\tpublic addActions(actions: PaginatedMessageAction[]): this {\n\t\tfor (const action of actions) this.addAction(action);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds an action to the existing ones. This will be added as the last action.\n\t * @param action The action to add.\n\t * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.\n\t */\n\tpublic addAction(action: PaginatedMessageAction): this {\n\t\tif (actionIsButtonOrMenu(action)) {\n\t\t\tthis.actions.set(action.customId, action);\n\t\t} else {\n\t\t\tthis.actions.set(action.url, action);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t// #endregion\n\t// #region page related methods\n\n\t/**\n\t * Checks whether or not the handler has a specific page.\n\t * @param index The index to check.\n\t */\n\tpublic hasPage(index: number): boolean {\n\t\treturn index >= 0 && index < this.pages.length;\n\t}\n\n\t/**\n\t * Clears all current pages and messages and sets them. The order given is the order they will be used.\n\t * @param pages The pages to set.\n\t */\n\tpublic setPages(pages: PaginatedMessagePage[]) {\n\t\tthis.pages = [];\n\t\tthis.messages = [];\n\t\tthis.addPages(pages);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a page to the existing ones. This will be added as the last page.\n\t * @remark While you can use this method you should first check out\n\t * {@link PaginatedMessage.addPageBuilder},\n\t * {@link PaginatedMessage.addPageContent} and\n\t * {@link PaginatedMessage.addPageEmbed} as\n\t * these are easier functional methods of adding pages and will likely already suffice for your needs.\n\t *\n\t * @param page The page to add.\n\t */\n\tpublic addPage(page: PaginatedMessagePage): this {\n\t\t// Do not allow more than 25 pages, and send a warning when people try to do so.\n\t\tif (this.pages.length === 25) {\n\t\t\tif (!this.hasEmittedMaxPageWarning) {\n\t\t\t\tprocess.emitWarning(\n\t\t\t\t\t'Maximum amount of pages exceeded for PaginatedMessage. Please check your instance of PaginatedMessage and ensure that you do not exceed 25 pages total.',\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'PaginatedMessageExceededMessagePageAmount',\n\t\t\t\t\t\tcode: 'PAGINATED_MESSAGE_EXCEEDED_MAXIMUM_AMOUNT_OF_PAGES',\n\t\t\t\t\t\tdetail: `If you do need more than 25 pages you can extend the class and overwrite the actions in the constructor.`\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tthis.hasEmittedMaxPageWarning = true;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.pages.push(page);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.\n\t * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t * const { MessageEmbed } = require('discord.js');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageBuilder((builder) => {\n\t * \t\tconst embed = new MessageEmbed()\n\t * \t\t\t.setColor('#FF0000')\n\t * \t\t\t.setDescription('example description');\n\t *\n\t * \t\treturn builder\n\t * \t\t\t.setContent('example content')\n\t * \t\t\t.setEmbeds([embed]);\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const { MessageEmbed } = require('discord.js');\n\t * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const embed = new MessageEmbed()\n\t * \t.setColor('#FF0000')\n\t * \t.setDescription('example description');\n\t *\n\t * const builder = new MessageBuilder()\n\t * \t.setContent('example content')\n\t * \t.setEmbeds([embed]);\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageBuilder(builder);\n\t * ```\n\t */\n\tpublic addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this {\n\t\treturn this.addPage(isFunction(builder) ? builder(new MessageBuilder()) : builder);\n\t}\n\n\t/**\n\t * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.\n\t * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t * const { MessageEmbed } = require('discord.js');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addAsyncPageBuilder(async (builder) => {\n\t * \t\tconst someRemoteData = await fetch('https://contoso.com/api/users');\n\t *\n\t * \t\tconst embed = new MessageEmbed()\n\t * \t\t\t.setColor('#FF0000')\n\t * \t\t\t.setDescription(someRemoteData.data);\n\t *\n\t * \t\treturn builder\n\t * \t\t\t.setContent('example content')\n\t * \t\t\t.setEmbeds([embed]);\n\t * });\n\t * ```\n\t */\n\tpublic addAsyncPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => Promise<MessageBuilder>)): this {\n\t\treturn this.addPage(async () => (isFunction(builder) ? builder(new MessageBuilder()) : builder));\n\t}\n\n\t/**\n\t * Adds a page to the existing ones using simple message content. This will be added as the last page.\n\t * @param content The content to set.\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageContent('example content');\n\t * ```\n\t */\n\tpublic addPageContent(content: string): this {\n\t\treturn this.addPage({ content });\n\t}\n\n\t/**\n\t * Adds a page to the existing ones using a {@link MessageEmbed}. This wil be added as the last page.\n\t * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageEmbed((embed) => {\n\t * \t\tembed\n\t * \t\t\t.setColor('#FF0000')\n\t * \t\t\t.setDescription('example description');\n\t *\n\t * \t\treturn embed;\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const embed = new MessageEmbed()\n\t * \t.setColor('#FF0000')\n\t * \t.setDescription('example description');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageEmbed(embed);\n\t * ```\n\t */\n\tpublic addPageEmbed(embed: MessageEmbed | ((embed: MessageEmbed) => MessageEmbed)): this {\n\t\treturn this.addPage({ embeds: isFunction(embed) ? [embed(new MessageEmbed())] : [embed] });\n\t}\n\n\t/**\n\t * Adds a page to the existing ones asynchronously using a {@link MessageEmbed}. This wil be added as the last page.\n\t * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addAsyncPageEmbed(async (embed) => {\n\t *\t\tconst someRemoteData = await fetch('https://contoso.com/api/users');\n\t *\n\t * \t\tembed\n\t * \t\t\t.setColor('#FF0000')\n\t * \t\t\t.setDescription(someRemoteData.data);\n\t *\n\t * \t\treturn embed;\n\t * });\n\t * ```\n\t */\n\tpublic addAsyncPageEmbed(embed: MessageEmbed | ((builder: MessageEmbed) => Promise<MessageEmbed>)): this {\n\t\treturn this.addPage(async () => ({ embeds: isFunction(embed) ? [await embed(new MessageEmbed())] : [embed] }));\n\t}\n\n\t/**\n\t * Adds a page to the existing ones asynchronously using multiple {@link MessageEmbed}'s. This wil be added as the last page.\n\t * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.\n\t * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add\n\t * as many embeds as you want, albeit manually\n\t * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds\n\t * \t\tembed1\n\t * \t\t\t.setColor('#FF0000')\n\t * \t\t\t.setDescription('example description 1');\n\t *\n\t * \t\tembed2\n\t * \t\t\t.setColor('#00FF00')\n\t * \t\t\t.setDescription('example description 2');\n\t *\n\t * \t\tembed3\n\t * \t\t\t.setColor('#0000FF')\n\t * \t\t\t.setDescription('example description 3');\n\t *\n\t * \t\treturn [embed1, embed2, embed3];\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const embed1 = new MessageEmbed()\n\t * \t.setColor('#FF0000')\n\t * \t.setDescription('example description 1');\n\t *\n\t * const embed2 = new MessageEmbed()\n\t * \t.setColor('#00FF00')\n\t * \t.setDescription('example description 2');\n\t *\n\t * const embed3 = new MessageEmbed()\n\t * \t.setColor('#0000FF')\n\t * \t.setDescription('example description 3');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds\n\t * ```\n\t */\n\tpublic addPageEmbeds(\n\t\tembeds:\n\t\t\t| MessageEmbed[]\n\t\t\t| ((\n\t\t\t\t\tembed1: MessageEmbed,\n\t\t\t\t\tembed2: MessageEmbed,\n\t\t\t\t\tembed3: MessageEmbed,\n\t\t\t\t\tembed4: MessageEmbed,\n\t\t\t\t\tembed5: MessageEmbed,\n\t\t\t\t\tembed6: MessageEmbed,\n\t\t\t\t\tembed7: MessageEmbed,\n\t\t\t\t\tembed8: MessageEmbed,\n\t\t\t\t\tembed9: MessageEmbed,\n\t\t\t\t\tembed10: MessageEmbed\n\t\t\t  ) => MessageEmbed[])\n\t): this {\n\t\tlet processedEmbeds = isFunction(embeds)\n\t\t\t? embeds(\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\tnew MessageEmbed()\n\t\t\t  )\n\t\t\t: embeds;\n\n\t\tif (processedEmbeds.length > 10) {\n\t\t\tprocessedEmbeds = processedEmbeds.slice(0, 10);\n\t\t}\n\n\t\treturn this.addPage({ embeds: processedEmbeds });\n\t}\n\n\t/**\n\t * Adds a page to the existing ones using multiple {@link MessageEmbed}'s. This wil be added as the last page.\n\t * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.\n\t * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add\n\t * as many embeds as you want, albeit manually\n\t * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {\n\t * \tconst someRemoteData = (await fetch('https://contoso.com/api/users')) as any;\n\t *\n\t * \tfor (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {\n\t * \t\tswitch (index) {\n\t * \t\t\tcase '0': {\n\t * \t\t\t\tembed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);\n\t * \t\t\t\tbreak;\n\t * \t\t\t}\n\t * \t\t\tcase '1': {\n\t * \t\t\t\tembed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);\n\t * \t\t\t\tbreak;\n\t * \t\t\t}\n\t * \t\t\tcase '2': {\n\t * \t\t\t\tembed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);\n\t * \t\t\t\tbreak;\n\t * \t\t\t}\n\t * \t\t}\n\t * \t}\n\t *\n\t * \treturn [embed0, embed1, embed2];\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');\n\t *\n\t * const embed1 = new MessageEmbed()\n\t * \t.setColor('#FF0000')\n\t * \t.setDescription('example description 1');\n\t *\n\t * const embed2 = new MessageEmbed()\n\t * \t.setColor('#00FF00')\n\t * \t.setDescription('example description 2');\n\t *\n\t * const embed3 = new MessageEmbed()\n\t * \t.setColor('#0000FF')\n\t * \t.setDescription('example description 3');\n\t *\n\t * const paginatedMessage = new PaginatedMessage()\n\t * \t.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds\n\t * ```\n\t */\n\tpublic addAsyncPageEmbeds(\n\t\tembeds:\n\t\t\t| MessageEmbed[]\n\t\t\t| ((\n\t\t\t\t\tembed1: MessageEmbed,\n\t\t\t\t\tembed2: MessageEmbed,\n\t\t\t\t\tembed3: MessageEmbed,\n\t\t\t\t\tembed4: MessageEmbed,\n\t\t\t\t\tembed5: MessageEmbed,\n\t\t\t\t\tembed6: MessageEmbed,\n\t\t\t\t\tembed7: MessageEmbed,\n\t\t\t\t\tembed8: MessageEmbed,\n\t\t\t\t\tembed9: MessageEmbed,\n\t\t\t\t\tembed10: MessageEmbed\n\t\t\t  ) => Promise<MessageEmbed[]>)\n\t): this {\n\t\treturn this.addPage(async () => {\n\t\t\tlet processedEmbeds = isFunction(embeds)\n\t\t\t\t? await embeds(\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed(),\n\t\t\t\t\t\tnew MessageEmbed()\n\t\t\t\t  )\n\t\t\t\t: embeds;\n\n\t\t\tif (processedEmbeds.length > 10) {\n\t\t\t\tprocessedEmbeds = processedEmbeds.slice(0, 10);\n\t\t\t}\n\n\t\t\treturn { embeds: processedEmbeds };\n\t\t});\n\t}\n\n\t/**\n\t * Add pages to the existing ones. The order given is the order they will be used.\n\t * @param pages The pages to add.\n\t */\n\tpublic addPages(pages: PaginatedMessagePage[]): this {\n\t\tfor (const page of pages) this.addPage(page);\n\t\treturn this;\n\t}\n\n\t// #endregion\n\n\t/**\n\t * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.\n\t * The handler will start collecting message component interactions.\n\t *\n\t * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.\n\t * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.\n\t *\n\t * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.\n\t * Generally this will be the command message or an interaction\n\t * (either a {@link CommandInteraction}, a {@link ContextMenuInteraction}, a {@link SelectMenuInteraction} or a {@link ButtonInteraction}),\n\t * but it can also be another message from your client, i.e. to indicate a loading state.\n\t *\n\t * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.\n\t * If `messageOrInteraction` is an instance of {@link Message} then this defaults to {@link Message.author messageOrInteraction.author},\n\t * and if it is an instance of {@link CommandInteraction} then it defaults to {@link CommandInteraction.user messageOrInteraction.user}.\n\t */\n\tpublic async run(\n\t\tmessageOrInteraction: Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction,\n\t\ttarget?: User\n\t): Promise<this> {\n\t\t// If there is no channel then exit early and potentially emit a warning\n\t\tif (!messageOrInteraction.channel) {\n\t\t\tconst isInteraction = runsOnInteraction(messageOrInteraction);\n\t\t\tlet shouldEmitWarning = this.emitPartialDMChannelWarning;\n\n\t\t\t// If we are to emit a warning,\n\t\t\t//   then check if a warning was already emitted,\n\t\t\t//   in which case we don't want to emit a warning.\n\t\t\tif (shouldEmitWarning && this.hasEmittedPartialDMChannelWarning) {\n\t\t\t\tshouldEmitWarning = false;\n\t\t\t}\n\n\t\t\t// If we are to emit a warning,\n\t\t\t//   then check if the interaction is an interaction based command,\n\t\t\t//   and check if the client has the `'CHANNEL'` partial,\n\t\t\t//   in which case we don't want to emit a warning.\n\t\t\tif (shouldEmitWarning && isInteraction && messageOrInteraction.client.options.partials?.includes('CHANNEL')) {\n\t\t\t\tshouldEmitWarning = false;\n\t\t\t}\n\n\t\t\t// IF we are to emit a warning,\n\t\t\t//   then check if the interaction is a message based command,\n\t\t\t//   and check if the client has the 'CHANNEL' partial,\n\t\t\t//   and check if the client has the 'DIRECT_MESSAGE' intent',\n\t\t\t//   in which case we don't want to emit a warning.\n\t\t\tif (\n\t\t\t\tshouldEmitWarning &&\n\t\t\t\t!isInteraction &&\n\t\t\t\tmessageOrInteraction.client.options.partials?.includes('CHANNEL') &&\n\t\t\t\tnew Intents(messageOrInteraction.client.options.intents).has(Intents.FLAGS.DIRECT_MESSAGES)\n\t\t\t) {\n\t\t\t\tshouldEmitWarning = false;\n\t\t\t}\n\n\t\t\t// If we should emit a warning then do so.\n\t\t\tif (shouldEmitWarning) {\n\t\t\t\tprocess.emitWarning(\n\t\t\t\t\t[\n\t\t\t\t\t\t'PaginatedMessage was initiated in a DM channel without the client having the required partial configured.',\n\t\t\t\t\t\t'If you want PaginatedMessage to work in DM channels then make sure you start your client with \"CHANNEL\" added to \"client.options.partials\".',\n\t\t\t\t\t\t'Furthermore if you are using message based commands (as opposed to application commands) then you will also need to add the \"DIRECT_MESSAGE\" intent to \"client.options.intents\"',\n\t\t\t\t\t\t'If you do not want to be alerted about this in the future then you can disable this warning by setting \"PaginatedMessage.emitPartialDMChannelWarning\" to \"false\", or use \"setEmitPartialDMChannelWarning(false)\" before calling \"run\".'\n\t\t\t\t\t].join('\\n'),\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'PaginatedMessageRunsInNonpartialDMChannel',\n\t\t\t\t\t\tcode: 'PAGINATED_MESSAGE_RUNS_IN_NON_PARTIAL_DM_CHANNEL'\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tthis.hasEmittedPartialDMChannelWarning = true;\n\t\t\t}\n\n\t\t\tawait safelyReplyToInteraction({\n\t\t\t\tmessageOrInteraction,\n\t\t\t\tinteractionEditReplyContent: this.#thisMazeWasNotMeantForYouContent,\n\t\t\t\tinteractionReplyContent: { ...this.#thisMazeWasNotMeantForYouContent, ephemeral: true },\n\t\t\t\tcomponentUpdateContent: this.#thisMazeWasNotMeantForYouContent,\n\t\t\t\tmessageMethod: 'reply',\n\t\t\t\tmessageMethodContent: this.#thisMazeWasNotMeantForYouContent\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// Assign the target based on whether a Message or CommandInteraction was passed in\n\t\ttarget ??= runsOnInteraction(messageOrInteraction) ? messageOrInteraction.user : messageOrInteraction.author;\n\n\t\t// Try to get the previous PaginatedMessage for this user\n\t\tconst paginatedMessage = PaginatedMessage.handlers.get(target.id);\n\n\t\t// If a PaginatedMessage was found then stop it\n\t\tpaginatedMessage?.collector?.stop();\n\n\t\t// If the message was sent by a bot, then set the response as this one\n\t\tif (runsOnInteraction(messageOrInteraction)) {\n\t\t\tif (messageOrInteraction.user.bot && messageOrInteraction.user.id === messageOrInteraction.client.user?.id) {\n\t\t\t\tthis.response = messageOrInteraction;\n\t\t\t}\n\t\t} else if (messageOrInteraction.author.bot && messageOrInteraction.author.id === messageOrInteraction.client.user?.id) {\n\t\t\tthis.response = messageOrInteraction;\n\t\t}\n\n\t\tawait this.resolvePagesOnRun();\n\n\t\t// Sanity checks to handle\n\t\tif (!this.messages.length) throw new Error('There are no messages.');\n\t\tif (!this.actions.size) throw new Error('There are no actions.');\n\n\t\tawait this.setUpMessage(messageOrInteraction, target);\n\t\tthis.setUpCollector(messageOrInteraction.channel, target);\n\n\t\tconst messageId = this.response!.id;\n\n\t\tif (this.collector) {\n\t\t\tthis.collector.once('end', () => {\n\t\t\t\tPaginatedMessage.messages.delete(messageId);\n\t\t\t\tPaginatedMessage.handlers.delete(target!.id);\n\t\t\t});\n\n\t\t\tPaginatedMessage.messages.set(messageId, this);\n\t\t\tPaginatedMessage.handlers.set(target.id, this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Executed whenever {@link PaginatedMessage.run} is called.\n\t */\n\tpublic async resolvePagesOnRun(): Promise<void> {\n\t\tfor (let i = 0; i < this.pages.length; i++) {\n\t\t\tawait this.resolvePage(i);\n\t\t}\n\t}\n\n\t/**\n\t * Executed whenever an action is triggered and resolved.\n\t * @param index The index to resolve.\n\t */\n\tpublic async resolvePage(index: number): Promise<PaginatedMessagePage> {\n\t\t// If the message was already processed, do not load it again:\n\t\tconst message = this.messages[index];\n\t\tif (!isNullish(message)) {\n\t\t\treturn message;\n\t\t}\n\n\t\t// Load the page and return it:\n\t\tconst resolved = await this.handlePageLoad(this.pages[index], index);\n\t\tthis.messages[index] = resolved;\n\n\t\treturn resolved;\n\t}\n\n\t/**\n\t * Clones the current handler into a new instance.\n\t */\n\tpublic clone(): PaginatedMessage {\n\t\tconst clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);\n\t\tclone.actions = this.actions;\n\t\tclone.response = this.response;\n\t\tclone.template = this.template;\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Sets up the message.\n\t *\n\t * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.\n\t * Generally this will be the command message or an interaction\n\t * (either a {@link CommandInteraction}, a {@link ContextMenuInteraction}, a {@link SelectMenuInteraction} or a {@link ButtonInteraction}),\n\t * but it can also be another message from your client, i.e. to indicate a loading state.\n\t *\n\t * @param author The author the handler is for.\n\t */\n\tprotected async setUpMessage(\n\t\tmessageOrInteraction: Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction,\n\t\ttargetUser: User\n\t): Promise<void> {\n\t\t// Get the current page\n\t\tlet page = this.messages[this.index]!;\n\n\t\t// If the page is a callback function such as with `addAsyncPageEmbed` then resolve it here\n\t\tpage = isFunction(page) ? await page(this.index, this.pages, this) : page;\n\n\t\t// Merge in the advanced options\n\t\tpage = { ...page, ...(this.paginatedMessageData ?? {}) };\n\n\t\t// If we do not have more than 1 page then there is no reason to add message components\n\t\tif (this.pages.length > 1) {\n\t\t\tconst messageComponents = await Promise.all(\n\t\t\t\t[...this.actions.values()].map<Promise<MessageButton | MessageSelectMenu>>(async (interaction) => {\n\t\t\t\t\treturn isMessageButtonInteraction(interaction)\n\t\t\t\t\t\t? new MessageButton(interaction)\n\t\t\t\t\t\t: new MessageSelectMenu({\n\t\t\t\t\t\t\t\toptions: await Promise.all(\n\t\t\t\t\t\t\t\t\tthis.pages.map(async (_, index) => ({\n\t\t\t\t\t\t\t\t\t\t...(await this.selectMenuOptions(index + 1, {\n\t\t\t\t\t\t\t\t\t\t\tauthor: targetUser,\n\t\t\t\t\t\t\t\t\t\t\tchannel: messageOrInteraction.channel,\n\t\t\t\t\t\t\t\t\t\t\tguild: isGuildBasedChannel(messageOrInteraction.channel) ? messageOrInteraction.channel.guild : null\n\t\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\t\tvalue: index.toString()\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t...interaction\n\t\t\t\t\t\t  });\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tpage.components = createPartitionedMessageRow(messageComponents);\n\t\t}\n\n\t\tif (this.response) {\n\t\t\tif (runsOnInteraction(this.response)) {\n\t\t\t\tif (this.response.replied || this.response.deferred) {\n\t\t\t\t\tawait this.response.editReply(page as WebhookEditMessageOptions);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.response.reply(page as WebhookEditMessageOptions);\n\t\t\t\t}\n\t\t\t} else if (isMessageInstance(this.response)) {\n\t\t\t\tawait this.response.edit(page as WebhookEditMessageOptions);\n\t\t\t}\n\t\t} else if (runsOnInteraction(messageOrInteraction)) {\n\t\t\tif (messageOrInteraction.replied || messageOrInteraction.deferred) {\n\t\t\t\tthis.response = await messageOrInteraction.editReply(page);\n\t\t\t} else {\n\t\t\t\tthis.response = await messageOrInteraction.reply({ ...page, fetchReply: true, ephemeral: false });\n\t\t\t}\n\t\t} else {\n\t\t\tthis.response = await messageOrInteraction.channel.send(page as MessageOptions);\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the message's collector.\n\t * @param channel The channel the handler is running at.\n\t * @param targetUser The user the handler is for.\n\t */\n\tprotected setUpCollector(channel: TextBasedChannel, targetUser: User): void {\n\t\tif (this.pages.length > 1) {\n\t\t\tthis.collector = new InteractionCollector<MessageComponentInteraction>(targetUser.client, {\n\t\t\t\tfilter: (interaction) =>\n\t\t\t\t\t!isNullish(this.response) && //\n\t\t\t\t\tinteraction.isMessageComponent() &&\n\t\t\t\t\tthis.actions.has(interaction.customId),\n\n\t\t\t\ttime: this.idle,\n\n\t\t\t\tguild: isGuildBasedChannel(channel) ? channel.guild : undefined,\n\n\t\t\t\tchannel,\n\n\t\t\t\tinteractionType: Constants.InteractionTypes.MESSAGE_COMPONENT,\n\n\t\t\t\t...(!isNullish(this.response) && !runsOnInteraction(this.response)\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tmessage: this.response\n\t\t\t\t\t  }\n\t\t\t\t\t: {})\n\t\t\t})\n\t\t\t\t.on('collect', this.handleCollect.bind(this, targetUser, channel))\n\t\t\t\t.on('end', this.handleEnd.bind(this));\n\t\t}\n\t}\n\n\t/**\n\t * Handles the load of a page.\n\t * @param page The page to be loaded.\n\t * @param channel The channel the paginated message runs at.\n\t * @param index The index of the current page.\n\t */\n\tprotected async handlePageLoad(page: PaginatedMessagePage, index: number): Promise<PaginatedMessageMessageOptionsUnion> {\n\t\t// Resolve the options from a function or an object\n\t\tconst options = isFunction(page) ? await page(index, this.pages, this) : page;\n\n\t\t// Clone the template to leave the original intact\n\t\tconst clonedTemplate = deepClone(this.template);\n\n\t\t// Apply the template to the page\n\t\tconst optionsWithTemplate = this.applyTemplate(clonedTemplate, options);\n\n\t\t// Apply the footer to the embed, if any\n\t\treturn this.applyFooter(optionsWithTemplate, index);\n\t}\n\n\t/**\n\t * Handles the `collect` event from the collector.\n\t * @param targetUser The user the handler is for.\n\t * @param channel The channel the handler is running at.\n\t * @param interaction The button interaction that was received.\n\t */\n\tprotected async handleCollect(\n\t\ttargetUser: User,\n\t\tchannel: Message['channel'],\n\t\tinteraction: ButtonInteraction | SelectMenuInteraction\n\t): Promise<void> {\n\t\tif (interaction.user.id === targetUser.id) {\n\t\t\t// Update the response to the latest interaction\n\t\t\tthis.response = interaction;\n\n\t\t\tconst action = this.actions.get(interaction.customId)!;\n\n\t\t\tif (actionIsButtonOrMenu(action)) {\n\t\t\t\tconst previousIndex = this.index;\n\n\t\t\t\tawait action.run({\n\t\t\t\t\tinteraction,\n\t\t\t\t\thandler: this,\n\t\t\t\t\tauthor: targetUser,\n\t\t\t\t\tchannel,\n\t\t\t\t\tresponse: this.response!,\n\t\t\t\t\tcollector: this.collector!\n\t\t\t\t});\n\n\t\t\t\tif (!this.stopPaginatedMessageCustomIds.includes(action.customId)) {\n\t\t\t\t\tconst newIndex = previousIndex === this.index ? previousIndex : this.index;\n\t\t\t\t\tconst messagePage = await this.resolvePage(newIndex);\n\t\t\t\t\tconst updateOptions = isFunction(messagePage) ? await messagePage(newIndex, this.pages, this) : messagePage;\n\n\t\t\t\t\tawait safelyReplyToInteraction({\n\t\t\t\t\t\tmessageOrInteraction: interaction,\n\t\t\t\t\t\tinteractionEditReplyContent: updateOptions,\n\t\t\t\t\t\tinteractionReplyContent: { ...this.#thisMazeWasNotMeantForYouContent, ephemeral: true },\n\t\t\t\t\t\tcomponentUpdateContent: updateOptions\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst interactionReplyOptions = await this.wrongUserInteractionReply(targetUser, interaction.user, {\n\t\t\t\tauthor: interaction.user,\n\t\t\t\tchannel: interaction.channel,\n\t\t\t\tguild: interaction.guild\n\t\t\t});\n\n\t\t\tawait interaction.reply(\n\t\t\t\tisObject(interactionReplyOptions)\n\t\t\t\t\t? interactionReplyOptions\n\t\t\t\t\t: { content: interactionReplyOptions, ephemeral: true, allowedMentions: { users: [], roles: [] } }\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `end` event from the collector.\n\t * @param reason The reason for which the collector was ended.\n\t */\n\tprotected handleEnd(_: Collection<Snowflake, ButtonInteraction | SelectMenuInteraction>, reason: string): void {\n\t\t// Remove all listeners from the collector:\n\t\tthis.collector?.removeAllListeners();\n\n\t\t// Do not remove components if the message, channel, or guild, was deleted:\n\t\tif (this.response && !PaginatedMessage.deletionStopReasons.includes(reason)) {\n\t\t\tvoid safelyReplyToInteraction({\n\t\t\t\tmessageOrInteraction: this.response,\n\t\t\t\tinteractionEditReplyContent: { components: [] },\n\t\t\t\tinteractionReplyContent: { ...this.#thisMazeWasNotMeantForYouContent, ephemeral: true },\n\t\t\t\tcomponentUpdateContent: { components: [] },\n\t\t\t\tmessageMethod: 'edit',\n\t\t\t\tmessageMethodContent: { components: [] }\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected applyFooter(message: PaginatedMessageMessageOptionsUnion, index: number): PaginatedMessageMessageOptionsUnion {\n\t\tif (!message.embeds?.length) {\n\t\t\treturn message;\n\t\t}\n\n\t\tconst embedsWithFooterApplied = deepClone(message.embeds);\n\n\t\tfor (const [idx, embed] of Object.entries(embedsWithFooterApplied)) {\n\t\t\tif (embed) {\n\t\t\t\tembed.footer ??= { text: this.template.embeds?.[Number(idx)]?.footer?.text ?? this.template.embeds?.[0]?.footer?.text ?? '' };\n\t\t\t\tembed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ''}${index + 1} / ${this.pages.length}${\n\t\t\t\t\tembed.footer.text ? ` ${this.embedFooterSeparator} ${embed.footer.text}` : ''\n\t\t\t\t}`;\n\t\t\t}\n\t\t}\n\n\t\treturn { ...message, embeds: embedsWithFooterApplied };\n\t}\n\n\tprivate applyTemplate(\n\t\ttemplate: PaginatedMessageMessageOptionsUnion,\n\t\toptions: PaginatedMessageMessageOptionsUnion\n\t): PaginatedMessageMessageOptionsUnion {\n\t\tconst embedData = this.applyTemplateEmbed(template.embeds, options.embeds);\n\n\t\treturn { ...template, ...options, embeds: embedData };\n\t}\n\n\tprivate applyTemplateEmbed(\n\t\ttemplateEmbed: PaginatedMessageEmbedResolvable,\n\t\tpageEmbeds: PaginatedMessageEmbedResolvable\n\t): PaginatedMessageEmbedResolvable {\n\t\tif (isNullish(pageEmbeds)) {\n\t\t\treturn templateEmbed ? [templateEmbed?.[0]] : undefined;\n\t\t}\n\n\t\tif (isNullish(templateEmbed)) {\n\t\t\treturn pageEmbeds;\n\t\t}\n\n\t\treturn this.mergeEmbeds(templateEmbed[0], pageEmbeds);\n\t}\n\n\tprivate mergeEmbeds(\n\t\ttemplateEmbed: Exclude<PaginatedMessageEmbedResolvable, undefined>[0],\n\t\tpageEmbeds: Exclude<PaginatedMessageEmbedResolvable, undefined>\n\t): Exclude<PaginatedMessageEmbedResolvable, undefined> {\n\t\tconst mergedEmbeds: Exclude<PaginatedMessageEmbedResolvable, undefined> = [];\n\n\t\tfor (const pageEmbed of pageEmbeds) {\n\t\t\tmergedEmbeds.push({\n\t\t\t\ttitle: pageEmbed.title ?? templateEmbed.title ?? undefined,\n\t\t\t\tdescription: pageEmbed.description ?? templateEmbed.description ?? undefined,\n\t\t\t\turl: pageEmbed.url ?? templateEmbed.url ?? undefined,\n\t\t\t\ttimestamp:\n\t\t\t\t\t(typeof pageEmbed.timestamp === 'string' ? new Date(pageEmbed.timestamp) : pageEmbed.timestamp) ??\n\t\t\t\t\t(typeof templateEmbed.timestamp === 'string' ? new Date(templateEmbed.timestamp) : templateEmbed.timestamp) ??\n\t\t\t\t\tundefined,\n\t\t\t\tcolor: pageEmbed.color ?? templateEmbed.color ?? undefined,\n\t\t\t\tfields: this.mergeArrays(templateEmbed.fields, pageEmbed.fields),\n\t\t\t\tauthor: pageEmbed.author ?? templateEmbed.author ?? undefined,\n\t\t\t\tthumbnail: pageEmbed.thumbnail ?? templateEmbed.thumbnail ?? undefined,\n\t\t\t\timage: pageEmbed.image ?? templateEmbed.image ?? undefined,\n\t\t\t\tvideo: pageEmbed.video ?? templateEmbed.video ?? undefined,\n\t\t\t\tfooter: pageEmbed.footer ?? templateEmbed.footer ?? undefined\n\t\t\t});\n\t\t}\n\n\t\treturn mergedEmbeds;\n\t}\n\n\tprivate mergeArrays<T>(template?: T[], array?: T[]): undefined | T[] {\n\t\tif (isNullish(array)) {\n\t\t\treturn template;\n\t\t}\n\n\t\tif (isNullish(template)) {\n\t\t\treturn array;\n\t\t}\n\n\t\treturn [...template, ...array];\n\t}\n\n\t/**\n\t * The default actions of this handler.\n\t */\n\tpublic static defaultActions: PaginatedMessageAction[] = [\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.goToPage',\n\t\t\ttype: Constants.MessageComponentTypes.SELECT_MENU,\n\t\t\trun: ({ handler, interaction }) => interaction.isSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))\n\t\t},\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.firstPage',\n\t\t\tstyle: 'PRIMARY',\n\t\t\temoji: '‚è™',\n\t\t\ttype: Constants.MessageComponentTypes.BUTTON,\n\t\t\trun: ({ handler }) => (handler.index = 0)\n\t\t},\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.previousPage',\n\t\t\tstyle: 'PRIMARY',\n\t\t\temoji: '‚óÄÔ∏è',\n\t\t\ttype: Constants.MessageComponentTypes.BUTTON,\n\t\t\trun: ({ handler }) => {\n\t\t\t\tif (handler.index === 0) {\n\t\t\t\t\thandler.index = handler.pages.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\t--handler.index;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.nextPage',\n\t\t\tstyle: 'PRIMARY',\n\t\t\temoji: '‚ñ∂Ô∏è',\n\t\t\ttype: Constants.MessageComponentTypes.BUTTON,\n\t\t\trun: ({ handler }) => {\n\t\t\t\tif (handler.index === handler.pages.length - 1) {\n\t\t\t\t\thandler.index = 0;\n\t\t\t\t} else {\n\t\t\t\t\t++handler.index;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.goToLastPage',\n\t\t\tstyle: 'PRIMARY',\n\t\t\temoji: '‚è©',\n\t\t\ttype: Constants.MessageComponentTypes.BUTTON,\n\t\t\trun: ({ handler }) => (handler.index = handler.pages.length - 1)\n\t\t},\n\t\t{\n\t\t\tcustomId: '@sapphire/paginated-messages.stop',\n\t\t\tstyle: 'DANGER',\n\t\t\temoji: '‚èπÔ∏è',\n\t\t\ttype: Constants.MessageComponentTypes.BUTTON,\n\t\t\trun: ({ collector }) => {\n\t\t\t\tcollector.stop();\n\t\t\t}\n\t\t}\n\t];\n\n\t/**\n\t * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client the `'CHANNEL'` partial.\n\t * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.\n\t *\n\t * @remark To overwrite this property change it somewhere in a \"setup\" file, i.e. where you also call `client.login()` for your client.\n\t * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setEmitPartialDMChannelWarning(newBoolean)`\n\t * @default true\n\t */\n\tpublic static emitPartialDMChannelWarning = true;\n\n\t/**\n\t * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}\n\t * @default ['@sapphire/paginated-messages.stop']\n\t * @remark To overwrite this property change it somewhere in a \"setup\" file, i.e. where you also call `client.login()` for your client.\n\t * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setStopPaginatedMessageCustomIds(customIds)`\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t *\n\t * PaginatedMessage.stopPaginatedMessageCustomIds = ['my-custom-stop-custom-id'];\n\t * ```\n\t */\n\tpublic static stopPaginatedMessageCustomIds = ['@sapphire/paginated-messages.stop'];\n\n\t/**\n\t * The reasons sent by {@linkplain https://discord.js.org/#/docs/main/stable/class/InteractionCollector?scrollTo=e-end InteractionCollector#end}\n\t * event when the message (or its owner) has been deleted.\n\t */\n\tpublic static deletionStopReasons = ['messageDelete', 'channelDelete', 'guildDelete'];\n\n\t/**\n\t * Custom text to show in front of the page index in the embed footer.\n\t * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.\n\t * @default \"\"\n\t * @remark To overwrite this property change it somewhere in a \"setup\" file, i.e. where you also call `client.login()` for your client.\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t *\n\t * PaginatedMessage.pageIndexPrefix = 'Page';\n\t * // This will make the footer of the embed something like \"Page 1/2\"\n\t * ```\n\t */\n\tpublic static pageIndexPrefix = '';\n\n\t/**\n\t * Custom separator for the page index in the embed footer.\n\t * @default \"‚Ä¢\"\n\t * @remark To overwrite this property change it somewhere in a \"setup\" file, i.e. where you also call `client.login()` for your client.\n\t * Alternatively, you can also customize it on a per-PaginatedMessage basis by passing `embedFooterSeparator` in the options of the constructor.\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t *\n\t * PaginatedMessage.embedFooterSeparator = '|';\n\t * // This will make the separator of the embed footer something like \"Page 1/2 | Today at 4:20\"\n\t * ```\n\t */\n\tpublic static embedFooterSeparator = '‚Ä¢';\n\n\t/**\n\t * The messages that are currently being handled by a {@link PaginatedMessage}\n\t * The key is the ID of the message that triggered this {@link PaginatedMessage}\n\t *\n\t * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.\n\t * This is important when having an editable commands solution.\n\t */\n\tpublic static readonly messages = new Map<string, PaginatedMessage>();\n\n\t/**\n\t * The current {@link InteractionCollector} handlers that are active.\n\t * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}\n\t *\n\t * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.\n\t * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.\n\t */\n\tpublic static readonly handlers = new Map<string, PaginatedMessage>();\n\n\t/**\n\t * A generator for {@link MessageSelectOption} that will be used to generate the options for the {@link MessageSelectMenu}.\n\t * We do not allow overwriting the {@link MessageSelectOption#value} property with this, as it is vital to how we handle\n\t * select menu interactions.\n\t *\n\t * @param pageIndex The index of the page to add to the {@link MessageSelectMenu}. We will add 1 to this number because our pages are 0 based,\n\t * so this will represent the pages as seen by the user.\n\t * @default\n\t * ```ts\n\t * {\n\t * \tlabel: `Page ${pageIndex}`\n\t * }\n\t * ```\n\t * @remark To overwrite this property change it in a \"setup\" file prior to calling `client.login()` for your client.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t *\n\t * PaginatedMessage.selectMenuOptions = (pageIndex) => ({\n\t * \t label: `Go to page: ${pageIndex}`,\n\t * \t description: 'This is a description'\n\t * });\n\t * ```\n\t */\n\tpublic static selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction = (pageIndex) => ({ label: `Page ${pageIndex}` });\n\n\t/**\n\t * A generator for {@link MessageComponentInteraction#reply} that will be called and sent whenever an untargeted user interacts with one of the buttons.\n\t * When modifying this it is recommended that the message is set to be ephemeral so only the user that is pressing the buttons can see them.\n\t * Furthermore, we also recommend setting `allowedMentions: { users: [], roles: [] }`, so you don't have to worry about accidentally pinging anyone.\n\t *\n\t * When setting just a string, we will add `{ ephemeral: true, allowedMentions: { users: [], roles: [] } }` for you.\n\t *\n\t * @param targetUser The {@link User} this {@link PaginatedMessage} was intended for.\n\t * @param interactionUser The {@link User} that actually clicked the button.\n\t * @default\n\t * ```ts\n\t * {\n\t * \tcontent: `Please stop interacting with the components on this message. They are only for ${Formatters.userMention(targetUser.id)}.`,\n\t * \tephemeral: true,\n\t * \tallowedMentions: { users: [], roles: [] }\n\t * }\n\t * ```\n\t * @remark To overwrite this property change it in a \"setup\" file prior to calling `client.login()` for your client.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t *\n\t * // We  will add ephemeral and no allowed mention for string only overwrites\n\t * PaginatedMessage.wrongUserInteractionReply = (targetUser) =>\n\t *     `These buttons are only for ${Formatters.userMention(targetUser.id)}. Press them as much as you want, but I won't do anything with your clicks.`;\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessage } from '@sapphire/discord.js-utilities';\n\t * import { Formatters } from 'discord.js';\n\t *\n\t * PaginatedMessage.wrongUserInteractionReply = (targetUser) => ({\n\t * \tcontent: `These buttons are only for ${Formatters.userMention(\n\t * \t\ttargetUser.id\n\t * \t)}. Press them as much as you want, but I won't do anything with your clicks.`,\n\t * \tephemeral: true,\n\t * \tallowedMentions: { users: [], roles: [] }\n\t * });\n\t * ```\n\t */\n\tpublic static wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction = (targetUser: User) => ({\n\t\tcontent: `Please stop interacting with the components on this message. They are only for ${Formatters.userMention(targetUser.id)}.`,\n\t\tephemeral: true,\n\t\tallowedMentions: { users: [], roles: [] }\n\t});\n\n\tprivate static resolveTemplate(template?: MessageEmbed | MessageOptions): MessageOptions {\n\t\tif (template === undefined) {\n\t\t\treturn {};\n\t\t}\n\n\t\tif (template instanceof MessageEmbed) {\n\t\t\treturn { embeds: [template] };\n\t\t}\n\n\t\treturn template;\n\t}\n}\n\nexport interface PaginatedMessage {\n\tconstructor: typeof PaginatedMessage;\n}\n","import { chunk, partition } from '@sapphire/utilities';\nimport type { APIMessage } from 'discord-api-types/v9';\nimport {\n\tConstants,\n\tMessage,\n\tMessageActionRow,\n\ttype ButtonInteraction,\n\ttype CommandInteraction,\n\ttype ContextMenuInteraction,\n\ttype InteractionButtonOptions,\n\ttype MessageButton,\n\ttype MessageSelectMenu,\n\ttype MessageSelectMenuOptions,\n\ttype SelectMenuInteraction\n} from 'discord.js';\nimport { isMessageInstance } from '../type-guards';\nimport type {\n\tPaginatedMessageAction,\n\tPaginatedMessageActionButton,\n\tPaginatedMessageActionLink,\n\tPaginatedMessageActionMenu,\n\tSafeReplyToInteractionParameters\n} from './PaginatedMessageTypes';\n\n/**\n * Checks whether the PaginatedMessage runs on an {@link CommandInteraction}, {@link ContextMenuInteraction}, {@link SelectMenuInteraction} or {@link Message}\n * @param messageOrInteraction The message or interaction that the PaginatedMessage runs on\n * @returns `true` if the PaginatedMessage runs on an an {@link CommandInteraction}, {@link ContextMenuInteraction} or {@link SelectMenuInteraction}, `false` if it runs on a {@link Message}\n */\nexport function runsOnInteraction(\n\tmessageOrInteraction: APIMessage | Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction\n): messageOrInteraction is CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction {\n\treturn !(messageOrInteraction instanceof Message);\n}\n\nexport function actionIsButtonOrMenu(action: PaginatedMessageAction): action is PaginatedMessageActionButton | PaginatedMessageActionMenu {\n\treturn (\n\t\taction.type === Constants.MessageComponentTypes.SELECT_MENU ||\n\t\t((action as PaginatedMessageActionButton | PaginatedMessageActionLink).style !== 'LINK' &&\n\t\t\t(action as PaginatedMessageActionButton | PaginatedMessageActionLink).style !== Constants.MessageButtonStyles.LINK)\n\t);\n}\n\nexport function isMessageButtonInteraction(\n\tinteraction: InteractionButtonOptions | MessageSelectMenuOptions\n): interaction is InteractionButtonOptions {\n\treturn interaction.type === Constants.MessageComponentTypes.BUTTON;\n}\n\nexport function isMessageButtonComponent(component: MessageButton | MessageSelectMenu): component is MessageButton {\n\treturn component.type === 'BUTTON';\n}\n\nexport function createPartitionedMessageRow(components: (MessageButton | MessageSelectMenu)[]): MessageActionRow[] {\n\t// Partition the components into two groups: buttons and select menus\n\tconst [messageButtons, selectMenus] = partition(components, isMessageButtonComponent);\n\n\t// Chunk the button components in sets of 5, the maximum of 1 MessageActionRow\n\tconst chunkedButtonComponents = chunk(messageButtons, 5);\n\n\t// Map all the button components to MessageActionRows\n\tconst messageButtonActionRows = chunkedButtonComponents.map((componentsChunk) =>\n\t\tnew MessageActionRow() //\n\t\t\t.setComponents(componentsChunk)\n\t);\n\n\t// Map all the select menu components to MessageActionRows\n\tconst selectMenuActionRows = selectMenus.map((component) =>\n\t\tnew MessageActionRow() //\n\t\t\t.setComponents(component)\n\t);\n\n\treturn [...messageButtonActionRows, ...selectMenuActionRows];\n}\n\n/**\n * Safely replies to a message or interaction. This is primarily to save duplicated code in the main `PaginatedMessage` class\n * @param parameters The parameters to create a safe reply to interaction parameters\n */\nexport async function safelyReplyToInteraction<T extends 'edit' | 'reply'>(parameters: SafeReplyToInteractionParameters<T>) {\n\tif (runsOnInteraction(parameters.messageOrInteraction)) {\n\t\tif (parameters.messageOrInteraction.replied || parameters.messageOrInteraction.deferred) {\n\t\t\tawait parameters.messageOrInteraction.editReply(parameters.interactionEditReplyContent);\n\t\t} else if (parameters.messageOrInteraction.isMessageComponent()) {\n\t\t\tawait parameters.messageOrInteraction.update(parameters.componentUpdateContent);\n\t\t} else {\n\t\t\tawait parameters.messageOrInteraction.reply(parameters.interactionReplyContent);\n\t\t}\n\t} else if (parameters.messageMethodContent && parameters.messageMethod && isMessageInstance(parameters.messageOrInteraction)) {\n\t\tawait parameters.messageOrInteraction[parameters.messageMethod](parameters.messageMethodContent as any);\n\t}\n}\n","import { isFunction } from '@sapphire/utilities';\nimport { MessageEmbed, type MessageEmbedOptions } from 'discord.js';\nimport { PaginatedMessage } from './PaginatedMessage';\n\n/**\n * This is a utility of {@link PaginatedMessage}, except it exclusively adds pagination inside a field of an embed.\n * You must either use this class directly or extend it.\n *\n * It differs from PaginatedMessageEmbedFields as the items here are the shape you want, and are then concatenated\n * in a single field with a given formatter function, whereas PaginatedMessageEmbedFields takes fields as the items\n * and add them to the embed.\n *\n * @example\n * ```typescript\n * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';\n *\n * new PaginatedFieldMessageEmbed()\n *    .setTitleField('Test pager field')\n *    .setTemplate({ embed })\n *    .setItems([\n *       { title: 'Sapphire Framework', value: 'discord.js Framework' },\n *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },\n *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }\n *     ])\n *    .formatItems((item) => `${item.title}\\n${item.value}`)\n *    .setItemsPerPage(2)\n *    .make()\n *    .run(message);\n * ```\n */\nexport class PaginatedFieldMessageEmbed<T> extends PaginatedMessage {\n\tprivate embedTemplate: MessageEmbed = new MessageEmbed();\n\tprivate totalPages = 0;\n\tprivate items: T[] = [];\n\tprivate itemsPerPage = 10;\n\tprivate fieldTitle = '';\n\n\t/**\n\t * Set the items to paginate.\n\t * @param items The pages to set\n\t */\n\tpublic setItems(items: T[]) {\n\t\tthis.items = items;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the title of the embed field that will be used to paginate the items.\n\t * @param title The field title\n\t */\n\tpublic setTitleField(title: string) {\n\t\tthis.fieldTitle = title;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of items that should be shown per page.\n\t * @param itemsPerPage The number of items\n\t */\n\tpublic setItemsPerPage(itemsPerPage: number) {\n\t\tthis.itemsPerPage = itemsPerPage;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.\n\t *\n\t * @param template MessageEmbed\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';\n\t * import { MessageEmbed } from 'discord.js';\n\t *\n\t * new PaginatedFieldMessageEmbed().setTemplate(new MessageEmbed().setTitle('Test pager embed')).make().run(message);\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';\n\t * import { MessageEmbed } from 'discord.js';\n\t *\n\t * new PaginatedFieldMessageEmbed().setTemplate({ title: 'Test pager embed' }).make().run(message);\n\t * ```\n\t */\n\tpublic setTemplate(template: MessageEmbedOptions | MessageEmbed | ((embed: MessageEmbed) => MessageEmbed)) {\n\t\tthis.embedTemplate = this.resolveTemplate(template);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets a format callback that will be mapped to each embed field in the array of items when the embed is paginated. This should convert each item to a format that is either text itself or can be serialized as text.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';\n\t *\n\t * new PaginatedFieldMessageEmbed()\n\t *    .setTitleField('Test field')\n\t *    .setTemplate({ embed })\n\t *    .setItems([\n\t *       { title: 'Sapphire Framework', value: 'discord.js Framework' },\n\t *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },\n\t *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }\n\t *     ])\n\t *    .formatItems((item) => `${item.title}\\n${item.value}`)\n\t *    .make()\n\t *    .run(message);\n\t * ```\n\t * @param value The formatter callback to be applied to each embed item\n\t */\n\tpublic formatItems(formatter: (item: T, index: number, array: T[]) => any) {\n\t\tthis.items = this.items.map(formatter);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the pages of the given array.\n\t *\n\t * You must call the [[PaginatedFieldMessageEmbed.make]] and [[PaginatedFieldMessageEmbed.run]] methods last, in that order, for the pagination to work.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';\n\t *\n\t * new PaginatedFieldMessageEmbed()\n\t *    .setTitleField('Test field')\n\t *    .setTemplate({ embed })\n\t *    .setItems([\n\t *       { title: 'Sapphire Framework', value: 'discord.js Framework' },\n\t *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },\n\t *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }\n\t *     ])\n\t *    .formatItems((item) => `${item.title}\\n${item.value}`)\n\t *    .make()\n\t *    .run(message);\n\t * ```\n\t */\n\tpublic make() {\n\t\tif (!this.fieldTitle.length) throw new Error('The title of the field to format must have a value.');\n\t\tif (!this.items.length) throw new Error('The items array is empty.');\n\t\tif (this.items.some((x) => !x)) throw new Error('The format of the array items is incorrect.');\n\n\t\tthis.totalPages = Math.ceil(this.items.length / this.itemsPerPage);\n\t\tthis.generatePages();\n\t\treturn this;\n\t}\n\n\tprivate generatePages() {\n\t\tconst template = this.embedTemplate instanceof MessageEmbed ? (this.embedTemplate.toJSON() as MessageEmbedOptions) : this.embedTemplate;\n\t\tfor (let i = 0; i < this.totalPages; i++) {\n\t\t\tconst clonedTemplate = new MessageEmbed(template);\n\t\t\tconst fieldsClone = this.embedTemplate.fields;\n\t\t\tclonedTemplate.fields = [];\n\n\t\t\tif (!clonedTemplate.color) clonedTemplate.setColor('RANDOM');\n\n\t\t\tconst data = this.paginateArray(this.items, i, this.itemsPerPage);\n\t\t\tthis.addPage({\n\t\t\t\tembeds: [clonedTemplate.addField(this.fieldTitle, data.join('\\n'), false).addFields(fieldsClone)]\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate paginateArray(items: T[], currentPage: number, perPageItems: number) {\n\t\tconst offset = currentPage * perPageItems;\n\t\treturn items.slice(offset, offset + perPageItems);\n\t}\n\n\tprivate resolveTemplate(template: MessageEmbed | MessageEmbedOptions | ((embed: MessageEmbed) => MessageEmbed)) {\n\t\tif (template instanceof MessageEmbed) {\n\t\t\treturn template;\n\t\t}\n\n\t\tif (isFunction(template)) {\n\t\t\treturn template(new MessageEmbed());\n\t\t}\n\n\t\treturn new MessageEmbed(template);\n\t}\n}\n","import { EmbedLimits } from '@sapphire/discord-utilities';\nimport { isFunction } from '@sapphire/utilities';\nimport { MessageEmbed, type EmbedFieldData, type MessageEmbedOptions } from 'discord.js';\nimport { PaginatedMessage } from './PaginatedMessage';\n\n/**\n * This is a utility of {@link PaginatedMessage}, except it exclusively paginates the fields of an embed.\n * You must either use this class directly or extend it.\n *\n * It differs from PaginatedFieldMessageEmbed as the items here are whole fields, that are added to the embed,\n * whereas PaginatedFieldMessageEmbed concatenates the items in a single field with a given formatter function.\n *\n * @example\n * ```typescript\n * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';\n *\n * new PaginatedMessageEmbedFields()\n * \t.setTemplate({ title: 'Test pager embed', color: '#006080' })\n * \t.setItems([\n * \t\t{ name: 'Sapphire Framework', value: 'discord.js Framework' },\n * \t\t{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },\n * \t\t{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }\n * \t])\n * \t.setItemsPerPage(2)\n * \t.make()\n * \t.run(message);\n * ```\n */\nexport class PaginatedMessageEmbedFields extends PaginatedMessage {\n\tprivate embedTemplate: MessageEmbed = new MessageEmbed();\n\tprivate totalPages = 0;\n\tprivate items: EmbedFieldData[] = [];\n\tprivate itemsPerPage = 10;\n\n\t/**\n\t * Set the items to paginate.\n\t * @param items The pages to set\n\t */\n\tpublic setItems(items: EmbedFieldData[]): this {\n\t\tthis.items = items;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of items that should be shown per page.\n\t * @param itemsPerPage The number of items\n\t */\n\tpublic setItemsPerPage(itemsPerPage: number): this {\n\t\tthis.itemsPerPage = itemsPerPage;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.\n\t * All fields in the given template will be overwritten when calling {@link PaginatedMessageEmbedFields.make}.\n\t *\n\t * @param template MessageEmbed\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';\n\t * import { MessageEmbed } from 'discord.js';\n\t *\n\t * new PaginatedMessageEmbedFields()\n\t * \t.setTemplate(new MessageEmbed().setColor('#006080').setTitle('Test pager embed'))\n\t * \t.setItems([{ name: 'My field', value: 'The field\\'s value' }])\n\t * \t.make()\n\t * \t.run(message);\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';\n\t * import { MessageEmbed } from 'discord.js';\n\t *\n\t * new PaginatedMessageEmbedFields()\n\t * \t.setTemplate({ title: 'Test pager embed', color: '#006080' })\n\t * \t.setItems([{ name: 'My field', value: 'The field\\'s value' }])\n\t * \t.make()\n\t * \t.run(message);\n\t * ```\n\t */\n\tpublic setTemplate(template: MessageEmbed | MessageEmbedOptions | ((embed: MessageEmbed) => MessageEmbed)): this {\n\t\tthis.embedTemplate = this.resolveTemplate(template);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the pages of the given array.\n\t *\n\t * You must call the [[PaginatedMessageEmbedFields.make]] and [[PaginatedMessageEmbedFields.run]] methods last, in that order, for the pagination to work.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';\n\t *\n\t * new PaginatedMessageEmbedFields()\n\t * \t.setItems([\n\t * \t\t{ name: 'Sapphire Framework', value: 'discord.js Framework' },\n\t * \t\t{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },\n\t * \t\t{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }\n\t * \t])\n\t * \t.setItemsPerPage(3)\n\t * \t.make()\n\t * \t.run(message);\n\t * ```\n\t */\n\tpublic make(): this {\n\t\tif (!this.items.length) throw new Error('The items array is empty.');\n\t\tif (this.itemsPerPage > EmbedLimits.MaximumFields) throw new Error(`Pages cannot contain more than ${EmbedLimits.MaximumFields} fields.`);\n\n\t\tthis.totalPages = Math.ceil(this.items.length / this.itemsPerPage);\n\t\tthis.generatePages();\n\t\treturn this;\n\t}\n\n\tprivate generatePages(): void {\n\t\tconst template = this.embedTemplate instanceof MessageEmbed ? (this.embedTemplate.toJSON() as MessageEmbedOptions) : this.embedTemplate;\n\t\tfor (let i = 0; i < this.totalPages; i++) {\n\t\t\tconst clonedTemplate = new MessageEmbed(template);\n\t\t\tconst fieldsClone = this.embedTemplate.fields;\n\t\t\tclonedTemplate.fields = [];\n\n\t\t\tif (!clonedTemplate.color) clonedTemplate.setColor('RANDOM');\n\n\t\t\tconst data = this.paginateArray(this.items, i, this.itemsPerPage - fieldsClone.length);\n\t\t\tthis.addPage({\n\t\t\t\tembeds: [clonedTemplate.addFields(...data, ...fieldsClone)]\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate paginateArray(items: EmbedFieldData[], currentPage: number, perPageItems: number): EmbedFieldData[] {\n\t\tconst offset = currentPage * perPageItems;\n\t\treturn items.slice(offset, offset + perPageItems);\n\t}\n\n\tprivate resolveTemplate(template: MessageEmbed | MessageEmbedOptions | ((embed: MessageEmbed) => MessageEmbed)) {\n\t\tif (template instanceof MessageEmbed) {\n\t\t\treturn template;\n\t\t}\n\n\t\tif (isFunction(template)) {\n\t\t\treturn template(new MessageEmbed());\n\t\t}\n\n\t\treturn new MessageEmbed(template);\n\t}\n}\n","import { isNullish, Nullish } from '@sapphire/utilities';\nimport { Permissions, type VoiceBasedChannel } from 'discord.js';\nimport { isDMChannel, isGuildBasedChannel, isVoiceBasedChannel } from './type-guards';\nimport type { ChannelTypes } from './utility-types';\n\nconst canReadMessagesPermissions = new Permissions(['VIEW_CHANNEL']);\n\n/**\n * Determines whether or not we can read messages in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can read messages in the specified channel.\n */\nexport function canReadMessages(channel: ChannelTypes | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return true;\n\n\treturn canDoUtility(channel, canReadMessagesPermissions);\n}\n\nconst canSendMessagesPermissions = new Permissions([canReadMessagesPermissions, 'SEND_MESSAGES']);\n\n/**\n * Determines whether or not we can send messages in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can send messages in the specified channel.\n */\nexport function canSendMessages(channel: ChannelTypes | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return true;\n\tif (channel.isThread() && !channel.sendable) return false;\n\n\treturn canDoUtility(channel, canSendMessagesPermissions);\n}\n\nconst canSendEmbedsPermissions = new Permissions([canSendMessagesPermissions, 'EMBED_LINKS']);\n\n/**\n * Determines whether or not we can send embeds in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can send embeds in the specified channel.\n */\nexport function canSendEmbeds(channel: ChannelTypes | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return true;\n\tif (channel.isThread() && !channel.sendable) return false;\n\n\treturn canDoUtility(channel, canSendEmbedsPermissions);\n}\n\nconst canSendAttachmentsPermissions = new Permissions([canSendMessagesPermissions, 'ATTACH_FILES']);\n\n/**\n * Determines whether or not we can send attachments in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can send attachments in the specified channel.\n */\nexport function canSendAttachments(channel: ChannelTypes | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return true;\n\tif (channel.isThread() && !channel.sendable) return false;\n\n\treturn canDoUtility(channel, canSendAttachmentsPermissions);\n}\n\nconst canReactPermissions = new Permissions([canSendMessagesPermissions, 'READ_MESSAGE_HISTORY', 'ADD_REACTIONS']);\n\n/**\n * Determines whether or not we can send react to messages in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can react to messages in the specified channel.\n */\nexport function canReact(channel: ChannelTypes | Nullish) {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return true;\n\tif (channel.isThread() && channel.archived) return false;\n\n\treturn canDoUtility(channel, canReactPermissions);\n}\n\nconst canRemoveAllReactionsPermissions = new Permissions([canReadMessagesPermissions, 'READ_MESSAGE_HISTORY', 'MANAGE_MESSAGES']);\n\n/**\n * Determines whether or not we can remove reactions from messages in a given channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not we can remove reactions from messages in the specified channel.\n */\nexport function canRemoveAllReactions(channel: ChannelTypes | Nullish) {\n\tif (isNullish(channel)) return false;\n\tif (isDMChannel(channel)) return false;\n\n\treturn canDoUtility(channel, canRemoveAllReactionsPermissions);\n}\n\nconst canJoinVoiceChannelPermissions = new Permissions(['CONNECT']);\n\n/**\n * Determines whether the client can join the given voice based channel.\n * @param channel The channel to test the permissions from.\n * @returns Whether or not the client can join the specified channel.\n */\nexport function canJoinVoiceChannel(channel: VoiceBasedChannel | Nullish): boolean {\n\tif (isNullish(channel)) return false;\n\tif (!isVoiceBasedChannel(channel)) return false;\n\tif (channel.userLimit >= channel.members.size) return false;\n\n\treturn canDoUtility(channel, canJoinVoiceChannelPermissions);\n}\n\nfunction canDoUtility(channel: ChannelTypes, permissionsToPass: Permissions) {\n\treturn isGuildBasedChannel(channel) ? channel.permissionsFor(channel.guild.me!)!.has(permissionsToPass) : true;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;;;ACQO,4BAA+C;AAAA,EAoC9C,YAAY,SAAoC;AA/BhD;AAMA;AAMA;AAMA;AAKA;AAMA;AAGN,SAAK,MAAM,SAAS,OAAO,gBAAe,SAAS;AACnD,SAAK,QAAQ,SAAS,SAAS,gBAAe,SAAS;AACvD,SAAK,UAAU,SAAS,WAAW,gBAAe,SAAS;AAC3D,SAAK,SAAS,SAAS,UAAU,gBAAe,SAAS;AACzD,SAAK,kBAAkB,SAAS,mBAAmB,gBAAe,SAAS;AAC3E,SAAK,QAAQ,SAAS,SAAS,gBAAe,SAAS;AAAA;AAAA,EAOjD,OAAO,KAAqB;AAClC,SAAK,MAAM;AACX,WAAO;AAAA;AAAA,EAOD,SAAS,OAAsB;AACrC,SAAK,QAAQ;AACb,WAAO;AAAA;AAAA,EAQD,WAAW,SAAwB;AACzC,SAAK,UAAU;AACf,WAAO;AAAA;AAAA,EASD,UAAU,QAAyC;AAEzD,QAAI,UAAU,OAAO,SAAS,IAAI;AACjC,eAAS,OAAO,MAAM,GAAG;AAAA;AAG1B,SAAK,SAAS;AACd,WAAO;AAAA;AAAA,EAOD,mBAAmB,iBAA2D;AACpF,SAAK,kBAAkB;AACvB,WAAO;AAAA;AAAA,EAOD,QAAQ,MAA0C;AACxD,SAAK,QAAQ,KAAK,OAAO,OAAO,SAAS,CAAC;AAC1C,WAAO;AAAA;AAAA,EAQD,QAAQ,MAA0C;AACxD,SAAK,QAAQ,CAAC;AACd,WAAO;AAAA;AAAA,EAQD,SAAS,OAA8C;AAC7D,SAAK,QAAQ;AACb,WAAO;AAAA;AAAA;AA5HF;AAAA;AAkIQ,cAlIR,gBAkIQ,YAAqC;;;AC1IpD;;;ACAA;AAEA;AAAA;AAAA;AAqBO,2BAA2B,SAA6D;AAC9F,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,qBAAqB,SAA0E;AACrG,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,wBAAwB,SAAiF;AAC/G,SAAO,SAAS,SAAS;AAAA;AADV;AAST,6BAA6B,SAAwE;AAC3G,SAAO,SAAS,SAAS;AAAA;AADV;AAUT,uCAAuC,SAAwE;AACrH,SAAO,QAAQ,IAAI,WAAW,IAAI;AAAA;AADnB;AAQT,uBAAuB,SAAyD;AACtF,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,wBAAwB,SAA0D;AACxF,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,uBAAuB,SAAyD;AACtF,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,wBAAwB,SAA0D;AACxF,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,wBAAwB,SAA0D;AACxF,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,yBAAyB,SAA2D;AAC1F,SAAO,SAAS,cAAc;AAAA;AADf;AAQT,6BAA6B,SAA2D;AAC9F,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,+BAA+B,SAA2D;AAChG,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,gCAAgC,SAA2D;AACjG,SAAO,SAAS,SAAS;AAAA;AADV;AAQT,4BAA4B,SAAmE;AACrG,MAAI,UAAU;AAAU,WAAO;AAE/B,SAAO,CAAC,UAAW,QAAkC;AAAA;AAHtC;AAUT,6BAA6B,SAA8D;AACjG,MAAI,UAAU;AAAU,WAAO;AAE/B,SAAO,QAAQ;AAAA;AAHA;AAUT,uBAAuB,SAA0C;AACvE,MAAI,UAAU;AAAU,WAAO;AAE/B,UAAQ,QAAQ;AAAA,SACV;AAAA,SACA;AAAA,SACA;AAAA,SACA;AAAA,SACA;AAAA,SACA;AAAA,SACA;AACJ,aAAO;AAAA,SACH;AAAA,SACA;AACJ,aAAQ,QAAgD;AAAA,SACpD;AAAA,SACA;AAAA,SACA;AACJ,aAAO,QAAS,QAA0B,QAAQ;AAAA;AAAA;AAlBrC;AA2BT,2BAA2B,SAAmD;AACpF,SAAO,mBAAmB;AAAA;AADX;;;ADlLT,yCAA2C;AAAA,EAoC1C,YAAY,MAAc,SAAiC,SAA2C;AAhCtG;AAKA;AAKA;AAKA,0CAAiC;AAKjC;AAKA;AAQN,SAAK,OAAO;AACZ,SAAK,UAAU,SAAS,WAAW,6BAA4B,uBAAuB,WAAW,KAAK;AACtG,SAAK,iBAAiB,SAAS,kBAAkB,6BAA4B,uBAAuB,kBAAkB;AACtH,SAAK,cAAc,SAAS,eAAe,6BAA4B,uBAAuB,eAAe;AAC7G,SAAK,UAAU;AAAA;AAAA,QAKA,iBACf,SACA,gBACA,WAC8C;AAC9C,QAAI,mBAAmB,UAAU;AAChC,UAAI,CAAC,WAAU,KAAK,gBAAgB,KAAK,YAAY,UAAU;AAC9D,aAAK,iBAAiB,MAAM,KAAK,YAAY,KAAK,KAAK;AAAA,aACjD;AACN,aAAK,iBAAiB,MAAM,QAAQ,KAAK,KAAK;AAAA;AAG/C,YAAM,YAAY,KAAK,eAAe,wBAAwB;AAAA,WAC1D,KAAK,2BAA2B,WAAW;AAAA,QAC9C,KAAK;AAAA,QACL,MAAM,KAAK;AAAA;AAGZ,UAAI,WAAW;AACf,YAAM,YAAsC,IAAI,QAAyB,CAAC,SAAS,WAAW;AAC7F,kBAAU,GAAG,WAAW,CAAC,MAAM;AAC9B,kBAAQ;AACR,qBAAW;AACX,oBAAU;AAAA;AAGX,kBAAU,GAAG,OAAO,CAAC,eAAc;AAClC,qBAAW;AACX,cAAI,CAAC,WAAU;AAAM,mBAAO,IAAI,MAAM;AAAA;AAAA;AAIxC,iBAAW,aAAY,WAAW;AACjC,YAAI;AAAU;AAEd,cAAM,KAAK,eAAe,MAAM;AAAA;AAGjC,YAAM,gBAAgB,MAAM;AAC5B,YAAM,QAAQ,eAAe;AAE7B,YAAM,WAAW,UAAU,KAAK,CAAC,MAAO,QAAO,MAAM,OAAO,UAAU;AAEtE,aAAO;AAAA,QACN;AAAA,QACA;AAAA,QACA,UAAU;AAAA,QACV,gBAAgB,KAAK;AAAA,QACrB,SAAS,KAAK;AAAA;AAAA;AAIhB,UAAM,IAAI,MAAM;AAAA;AAAA,EAOP,2BACT,WACA,gBAC4C;AAC5C,WAAO;AAAA,MACN,QAAQ,OAAO,UAA2B,SACzC,UAAU,SAAS,SAAS,MAAM,MAAM,SAAS,MAAM,QAAQ,OAC9D,QAAO,mBAAmB,aAAa,MAAM,eAAe,UAAU,QAAQ,KAAK,OAAO,eAAe,OAC1G,CAAC,KAAK;AAAA;AAAA;AAAA;AAjHH;AAAA;AAwHQ,cAxHR,6BAwHQ,0BAA0D;AAAA,EACvE,SAAS,KAAK;AAAA,EACd,gBAAgB;AAAA,EAChB,aAAa;AAAA;;;AE5HR,oDAA6C,4BAA8E;AAAA,EAgB1H,YAAY,SAAiC,SAAkD;AACrG,UAAM,WAAW,SAAS;AAbpB;AAKA;AAUN,SAAK,eAAe,SAAS,gBAAgB,gCAA+B;AAC5E,SAAK,cAAc,SAAS,eAAe,gCAA+B;AAAA;AAAA,QAUrD,IACrB,SACA,gBAC2D;AAC3D,UAAM,WAAW,MAAM,KAAK,iBAAiB,SAAS,gBAAgB,CAAC,KAAK,cAAc,KAAK;AAE/F,UAAM,YAAa,WAAU,OAAO,MAAM,UAAU,OAAO,UAAU,KAAK;AAG1E,WAAO,KAAK,iBAAiB,KAAK,UAAU,cAAc;AAAA;AAAA;AAvCrD;AAAA;AA6CQ,cA7CR,gCA6CQ,gBAAyC;AAKzC,cAlDR,gCAkDQ,eAAwC;;;ACxDvD;AAQO,mDAA6C,4BAAuE;AAAA,EAMnH,YAAY,SAAiC,SAA0C;AAC7F,UAAM,WAAW,SAAS;AAAA;AAAA,QAUL,IACrB,SACA,gBAC2D;AAC3D,QAAI,mBAAmB,UAAU;AAChC,UAAI,CAAC,WAAU,KAAK,gBAAgB,KAAK,YAAY,UAAU;AAC9D,aAAK,iBAAiB,MAAM,KAAK,YAAY,KAAK,KAAK;AAAA,aACjD;AACN,aAAK,iBAAiB,MAAM,QAAQ,KAAK,KAAK;AAAA;AAG/C,YAAM,YAAY,MAAM,QAAQ,cAAc;AAAA,WAC1C,KAAK,0BAA0B;AAAA,QAClC,KAAK;AAAA,QACL,MAAM,KAAK;AAAA,QACX,QAAQ,CAAC;AAAA;AAEV,YAAM,WAAW,UAAU;AAE3B,UAAI,CAAC,UAAU;AACd,cAAM,IAAI,MAAM;AAAA;AAGjB,aAAO,KAAK,iBACT;AAAA,QACA;AAAA,QACA,UAAU;AAAA,QACV,gBAAgB,KAAK;AAAA,QACrB,SAAS,KAAK;AAAA,UAEd;AAAA;AAGJ,UAAM,IAAI,MAAM;AAAA;AAAA,EAOT,0BAA0B,gBAAgF;AACjH,WAAO;AAAA,MACN,QAAQ,OAAO,YACb,QAAO,mBAAmB,aAAa,MAAM,eAAe,WAAW,QAAQ,OAAO,OAAO,eAAe,OAC7G,CAAC,QAAQ,OAAO;AAAA;AAAA;AAAA;AA7Db;;;ACFA,mDAA4C,4BAA6E;AAAA,EAmBxH,YAAY,SAAiC,SAAgD;AACnG,UAAM,UAAU,SAAS;AAhBnB;AAIA;AAIA;AAUN,SAAK,eAAe,SAAS,gBAAgB,+BAA8B;AAC3E,SAAK,QAAQ,SAAS,SAAS;AAC/B,SAAK,MAAM,SAAS,OAAO;AAAA;AAAA,QAUf,IACZ,SACA,gBACyD;AAEzD,QAAI,KAAK,QAAQ;AAAG,YAAM,IAAI,UAAU;AACxC,QAAI,KAAK,MAAM;AAAI,YAAM,IAAI,UAAU;AAEvC,UAAM,UAAU,MAAM,KAAK,EAAE,QAAQ,KAAK,MAAM,KAAK,QAAQ,KAAK,CAAC,GAAG,MAAc,IAAI,KAAK;AAC7F,UAAM,SAAS,KAAK,aAAa,MAAM,KAAK,OAAO,KAAK;AACxD,UAAM,WAAW,MAAM,KAAK,iBAAiB,SAAS,gBAAgB;AAEtE,UAAM,aAAa,OAAO,UAAU,CAAC,UAAW,WAAU,OAAO,MAAM,UAAU,OAAO,UAAU;AAClG,UAAM,SAAS,QAAQ;AAGvB,WAAO,KAAK,iBAAiB,KAAK,UAAU,WAAW;AAAA;AAAA;AAlDlD;AAAA;AAwDQ,cAxDR,+BAwDQ,gBAAe,CAAC,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO,iBAAO;;;ACxD9F,oDAA8C,4BAAuE;AAAA,EAWpH,YAAY,SAAiC,SAAkD;AACrG,UAAM,aAAa,SAAS;AARtB;AAUN,SAAK,YAAY,SAAS;AAAA;AAAA,QAUd,IACZ,SACA,gBACyE;AACzE,QAAI,CAAC,KAAK,WAAW;AAAQ,YAAM,IAAI,UAAU;AAEjD,UAAM,WAAW,MAAM,KAAK,iBAAiB,SAAS,gBAAgB,KAAK;AAE3E,WAAO,KAAK,iBAAiB,WAAW,SAAS,YAAY;AAAA;AAAA;AAhCxD;;;AC2FA,6BAAmE;AAAA,EAYlE,YACN,SACA,UACA,iBACC;AAZK;AAaN,QAAI;AAEJ,QAAI,mBAAmB,6BAA6B;AACnD,sBAAgB;AAAA,WACV;AACN,YAAM,cAAc,iBAAgB,WAAW,IAAI,YAAY,iBAAgB;AAE/E,UAAI,CAAC,aAAa;AACjB,cAAM,IAAI,MAAM;AAAA;AAGjB,sBAAgB,IAAI,YAAY,SAAS;AAAA;AAG1C,SAAK,WAAW;AAAA;AAAA,EAQV,IACN,SACA,gBACwE;AACxE,WAAO,KAAK,SAAS,IAAI,SAAS;AAAA;AAAA;AA3C7B;AAAA;AAmDQ,cAnDR,iBAmDQ,cAUV,oBAAI,IAAI;AAAA,EACX,CAAC,WAAW;AAAA,EACZ,CAAC,UAAU;AAAA,EACX,CAAC,YAAY;AAAA,EACb,CAAC,WAAW;AAAA;AAMC,cAvER,iBAuEQ,mBAAyC;;;ACxKxD;AACA;;;ACDA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACHA;AAEA;AAAA;AAAA;AAAA;AAAA;AA2BO,2BACN,sBACkH;AAClH,SAAO,CAAE,iCAAgC;AAAA;AAH1B;AAMT,8BAA8B,QAAqG;AACzI,SACC,OAAO,SAAS,UAAU,sBAAsB,eAC9C,OAAqE,UAAU,UAC/E,OAAqE,UAAU,UAAU,oBAAoB;AAAA;AAJjG;AAQT,oCACN,aAC0C;AAC1C,SAAO,YAAY,SAAS,UAAU,sBAAsB;AAAA;AAH7C;AAMT,kCAAkC,WAA0E;AAClH,SAAO,UAAU,SAAS;AAAA;AADX;AAIT,qCAAqC,YAAuE;AAElH,QAAM,CAAC,gBAAgB,eAAe,UAAU,YAAY;AAG5D,QAAM,0BAA0B,MAAM,gBAAgB;AAGtD,QAAM,0BAA0B,wBAAwB,IAAI,CAAC,oBAC5D,IAAI,mBACF,cAAc;AAIjB,QAAM,uBAAuB,YAAY,IAAI,CAAC,cAC7C,IAAI,mBACF,cAAc;AAGjB,SAAO,CAAC,GAAG,yBAAyB,GAAG;AAAA;AAnBxB;AA0BhB,wCAA2E,YAAiD;AAC3H,MAAI,kBAAkB,WAAW,uBAAuB;AACvD,QAAI,WAAW,qBAAqB,WAAW,WAAW,qBAAqB,UAAU;AACxF,YAAM,WAAW,qBAAqB,UAAU,WAAW;AAAA,eACjD,WAAW,qBAAqB,sBAAsB;AAChE,YAAM,WAAW,qBAAqB,OAAO,WAAW;AAAA,WAClD;AACN,YAAM,WAAW,qBAAqB,MAAM,WAAW;AAAA;AAAA,aAE9C,WAAW,wBAAwB,WAAW,iBAAiB,kBAAkB,WAAW,uBAAuB;AAC7H,UAAM,WAAW,qBAAqB,WAAW,eAAe,WAAW;AAAA;AAAA;AAVvD;;;AD/EtB;AAkHO,8BAAuB;AAAA,EAyGtB,YAAY;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,uBAAuB;AAAA,MACK,IAAI;AA9GjC,0DAAoC,EAAE,SAAS;AAMxC;AAKA,oCAAkI;AAKlI,qCAAsE;AAKtE,oCAA4C;AAK5C,mCAAU,oBAAI;AAKd,iCAAQ;AAOR,gCAAO,KAAK,SAAS;AAMrB;AAOA,2CAAkB,kBAAiB;AAOnC,gDAAuB,kBAAiB;AAMxC,yDAAgC,kBAAiB;AAQjD,uDAA8B,kBAAiB;AAI5C,gDAAuF;AAEvF,6CAA+D,kBAAiB;AAEhF,qDAA+E,kBAAiB;AAMhG,oDAA2B;AAS3B,6DAAoC;AAgB7C,SAAK,QAAQ,SAAS;AAEtB,eAAW,QAAQ,KAAK,OAAO;AAC9B,UAAI,WAAW,SAAS,SAAS,OAAO;AACvC,aAAK,SAAS,KAAK;AAAA;AAAA;AAIrB,eAAW,UAAU,WAAW,KAAK,YAAY,gBAAgB;AAChE,UAAI,qBAAqB,SAAS;AACjC,aAAK,QAAQ,IAAI,OAAO,UAAU;AAAA,aAC5B;AACN,aAAK,QAAQ,IAAI,OAAO,KAAK;AAAA;AAAA;AAI/B,SAAK,WAAW,kBAAiB,gBAAgB;AACjD,SAAK,kBAAkB,mBAAmB,kBAAiB;AAC3D,SAAK,uBAAuB,wBAAwB,kBAAiB;AACrE,SAAK,uBAAuB;AAAA;AAAA,EAWtB,qBAAqB,YAA6D;AACxF,SAAK,oBAAoB;AACzB,WAAO;AAAA;AAAA,EASD,6BAA6B,2BAAoF;AACvH,SAAK,4BAA4B;AACjC,WAAO;AAAA;AAAA,EASD,iCAAiC,+BAA+C;AACtF,SAAK,gCAAgC;AACrC,WAAO;AAAA;AAAA,EASD,+BAA+B,6BAA4C;AACjF,SAAK,8BAA8B;AACnC,WAAO;AAAA;AAAA,EAOD,SAAS,OAAqB;AACpC,SAAK,QAAQ;AACb,WAAO;AAAA;AAAA,EAOD,QAAQ,MAAoB;AAClC,SAAK,OAAO;AACZ,WAAO;AAAA;AAAA,EAqED,WAAW,SAAmC,wBAAwB,OAAa;AACzF,SAAK,QAAQ;AACb,WAAO,KAAK,WAAW,CAAC,GAAI,wBAAwB,kBAAiB,iBAAiB,IAAK,GAAG;AAAA;AAAA,EAQxF,WAAW,SAAyC;AAC1D,eAAW,UAAU;AAAS,WAAK,UAAU;AAC7C,WAAO;AAAA;AAAA,EAQD,UAAU,QAAsC;AACtD,QAAI,qBAAqB,SAAS;AACjC,WAAK,QAAQ,IAAI,OAAO,UAAU;AAAA,WAC5B;AACN,WAAK,QAAQ,IAAI,OAAO,KAAK;AAAA;AAG9B,WAAO;AAAA;AAAA,EAUD,QAAQ,OAAwB;AACtC,WAAO,SAAS,KAAK,QAAQ,KAAK,MAAM;AAAA;AAAA,EAOlC,SAAS,OAA+B;AAC9C,SAAK,QAAQ;AACb,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,WAAO;AAAA;AAAA,EAaD,QAAQ,MAAkC;AAEhD,QAAI,KAAK,MAAM,WAAW,IAAI;AAC7B,UAAI,CAAC,KAAK,0BAA0B;AACnC,gBAAQ,YACP,2JACA;AAAA,UACC,MAAM;AAAA,UACN,MAAM;AAAA,UACN,QAAQ;AAAA;AAGV,aAAK,2BAA2B;AAAA;AAGjC,aAAO;AAAA;AAGR,SAAK,MAAM,KAAK;AAEhB,WAAO;AAAA;AAAA,EAuCD,eAAe,SAA+E;AACpG,WAAO,KAAK,QAAQ,WAAW,WAAW,QAAQ,IAAI,oBAAoB;AAAA;AAAA,EAyBpE,oBAAoB,SAAwF;AAClH,WAAO,KAAK,QAAQ,YAAa,WAAW,WAAW,QAAQ,IAAI,oBAAoB;AAAA;AAAA,EAcjF,eAAe,SAAuB;AAC5C,WAAO,KAAK,QAAQ,EAAE;AAAA;AAAA,EA+BhB,aAAa,OAAqE;AACxF,WAAO,KAAK,QAAQ,EAAE,QAAQ,WAAW,SAAS,CAAC,MAAM,IAAI,mBAAmB,CAAC;AAAA;AAAA,EAsB3E,kBAAkB,OAAgF;AACxG,WAAO,KAAK,QAAQ,YAAa,GAAE,QAAQ,WAAW,SAAS,CAAC,MAAM,MAAM,IAAI,mBAAmB,CAAC;AAAA;AAAA,EAkD9F,cACN,QAcO;AACP,QAAI,kBAAkB,WAAW,UAC9B,OACA,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,kBAEJ;AAEH,QAAI,gBAAgB,SAAS,IAAI;AAChC,wBAAkB,gBAAgB,MAAM,GAAG;AAAA;AAG5C,WAAO,KAAK,QAAQ,EAAE,QAAQ;AAAA;AAAA,EAwDxB,mBACN,QAcO;AACP,WAAO,KAAK,QAAQ,YAAY;AAC/B,UAAI,kBAAkB,WAAW,UAC9B,MAAM,OACN,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,gBACJ,IAAI,kBAEJ;AAEH,UAAI,gBAAgB,SAAS,IAAI;AAChC,0BAAkB,gBAAgB,MAAM,GAAG;AAAA;AAG5C,aAAO,EAAE,QAAQ;AAAA;AAAA;AAAA,EAQZ,SAAS,OAAqC;AACpD,eAAW,QAAQ;AAAO,WAAK,QAAQ;AACvC,WAAO;AAAA;AAAA,QAqBK,IACZ,sBACA,QACgB;AAEhB,QAAI,CAAC,qBAAqB,SAAS;AAClC,YAAM,gBAAgB,kBAAkB;AACxC,UAAI,oBAAoB,KAAK;AAK7B,UAAI,qBAAqB,KAAK,mCAAmC;AAChE,4BAAoB;AAAA;AAOrB,UAAI,qBAAqB,iBAAiB,qBAAqB,OAAO,QAAQ,UAAU,SAAS,YAAY;AAC5G,4BAAoB;AAAA;AAQrB,UACC,qBACA,CAAC,iBACD,qBAAqB,OAAO,QAAQ,UAAU,SAAS,cACvD,IAAI,QAAQ,qBAAqB,OAAO,QAAQ,SAAS,IAAI,QAAQ,MAAM,kBAC1E;AACD,4BAAoB;AAAA;AAIrB,UAAI,mBAAmB;AACtB,gBAAQ,YACP;AAAA,UACC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACC,KAAK,OACP;AAAA,UACC,MAAM;AAAA,UACN,MAAM;AAAA;AAGR,aAAK,oCAAoC;AAAA;AAG1C,YAAM,yBAAyB;AAAA,QAC9B;AAAA,QACA,6BAA6B,mBAAK;AAAA,QAClC,yBAAyB,KAAK,mBAAK,oCAAmC,WAAW;AAAA,QACjF,wBAAwB,mBAAK;AAAA,QAC7B,eAAe;AAAA,QACf,sBAAsB,mBAAK;AAAA;AAG5B,aAAO;AAAA;AAIR,eAAW,kBAAkB,wBAAwB,qBAAqB,OAAO,qBAAqB;AAGtG,UAAM,mBAAmB,kBAAiB,SAAS,IAAI,OAAO;AAG9D,sBAAkB,WAAW;AAG7B,QAAI,kBAAkB,uBAAuB;AAC5C,UAAI,qBAAqB,KAAK,OAAO,qBAAqB,KAAK,OAAO,qBAAqB,OAAO,MAAM,IAAI;AAC3G,aAAK,WAAW;AAAA;AAAA,eAEP,qBAAqB,OAAO,OAAO,qBAAqB,OAAO,OAAO,qBAAqB,OAAO,MAAM,IAAI;AACtH,WAAK,WAAW;AAAA;AAGjB,UAAM,KAAK;AAGX,QAAI,CAAC,KAAK,SAAS;AAAQ,YAAM,IAAI,MAAM;AAC3C,QAAI,CAAC,KAAK,QAAQ;AAAM,YAAM,IAAI,MAAM;AAExC,UAAM,KAAK,aAAa,sBAAsB;AAC9C,SAAK,eAAe,qBAAqB,SAAS;AAElD,UAAM,YAAY,KAAK,SAAU;AAEjC,QAAI,KAAK,WAAW;AACnB,WAAK,UAAU,KAAK,OAAO,MAAM;AAChC,0BAAiB,SAAS,OAAO;AACjC,0BAAiB,SAAS,OAAO,OAAQ;AAAA;AAG1C,wBAAiB,SAAS,IAAI,WAAW;AACzC,wBAAiB,SAAS,IAAI,OAAO,IAAI;AAAA;AAG1C,WAAO;AAAA;AAAA,QAMK,oBAAmC;AAC/C,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC3C,YAAM,KAAK,YAAY;AAAA;AAAA;AAAA,QAQZ,YAAY,OAA8C;AAEtE,UAAM,UAAU,KAAK,SAAS;AAC9B,QAAI,CAAC,WAAU,UAAU;AACxB,aAAO;AAAA;AAIR,UAAM,WAAW,MAAM,KAAK,eAAe,KAAK,MAAM,QAAQ;AAC9D,SAAK,SAAS,SAAS;AAEvB,WAAO;AAAA;AAAA,EAMD,QAA0B;AAChC,UAAM,QAAQ,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK,OAAO,SAAS,MAAM,SAAS,KAAK,OAAO,QAAQ,KAAK;AACzG,UAAM,UAAU,KAAK;AACrB,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK;AACtB,WAAO;AAAA;AAAA,QAaQ,aACf,sBACA,YACgB;AAEhB,QAAI,OAAO,KAAK,SAAS,KAAK;AAG9B,WAAO,WAAW,QAAQ,MAAM,KAAK,KAAK,OAAO,KAAK,OAAO,QAAQ;AAGrE,WAAO,KAAK,SAAU,KAAK,wBAAwB;AAGnD,QAAI,KAAK,MAAM,SAAS,GAAG;AAC1B,YAAM,oBAAoB,MAAM,QAAQ,IACvC,CAAC,GAAG,KAAK,QAAQ,UAAU,IAAgD,OAAO,gBAAgB;AACjG,eAAO,2BAA2B,eAC/B,IAAI,cAAc,eAClB,IAAI,kBAAkB;AAAA,UACtB,SAAS,MAAM,QAAQ,IACtB,KAAK,MAAM,IAAI,OAAO,GAAG,UAAW;AAAA,eAC/B,MAAM,KAAK,kBAAkB,QAAQ,GAAG;AAAA,cAC3C,QAAQ;AAAA,cACR,SAAS,qBAAqB;AAAA,cAC9B,OAAO,oBAAoB,qBAAqB,WAAW,qBAAqB,QAAQ,QAAQ;AAAA;AAAA,YAEjG,OAAO,MAAM;AAAA;AAAA,aAGZ;AAAA;AAAA;AAKR,WAAK,aAAa,4BAA4B;AAAA;AAG/C,QAAI,KAAK,UAAU;AAClB,UAAI,kBAAkB,KAAK,WAAW;AACrC,YAAI,KAAK,SAAS,WAAW,KAAK,SAAS,UAAU;AACpD,gBAAM,KAAK,SAAS,UAAU;AAAA,eACxB;AACN,gBAAM,KAAK,SAAS,MAAM;AAAA;AAAA,iBAEjB,kBAAkB,KAAK,WAAW;AAC5C,cAAM,KAAK,SAAS,KAAK;AAAA;AAAA,eAEhB,kBAAkB,uBAAuB;AACnD,UAAI,qBAAqB,WAAW,qBAAqB,UAAU;AAClE,aAAK,WAAW,MAAM,qBAAqB,UAAU;AAAA,aAC/C;AACN,aAAK,WAAW,MAAM,qBAAqB,MAAM,KAAK,MAAM,YAAY,MAAM,WAAW;AAAA;AAAA,WAEpF;AACN,WAAK,WAAW,MAAM,qBAAqB,QAAQ,KAAK;AAAA;AAAA;AAAA,EAShD,eAAe,SAA2B,YAAwB;AAC3E,QAAI,KAAK,MAAM,SAAS,GAAG;AAC1B,WAAK,YAAY,IAAI,qBAAkD,WAAW,QAAQ;AAAA,QACzF,QAAQ,CAAC,gBACR,CAAC,WAAU,KAAK,aAChB,YAAY,wBACZ,KAAK,QAAQ,IAAI,YAAY;AAAA,QAE9B,MAAM,KAAK;AAAA,QAEX,OAAO,oBAAoB,WAAW,QAAQ,QAAQ;AAAA,QAEtD;AAAA,QAEA,iBAAiB,WAAU,iBAAiB;AAAA,WAExC,CAAC,WAAU,KAAK,aAAa,CAAC,kBAAkB,KAAK,YACtD;AAAA,UACA,SAAS,KAAK;AAAA,YAEd;AAAA,SAEF,GAAG,WAAW,KAAK,cAAc,KAAK,MAAM,YAAY,UACxD,GAAG,OAAO,KAAK,UAAU,KAAK;AAAA;AAAA;AAAA,QAUlB,eAAe,MAA4B,OAA6D;AAEvH,UAAM,UAAU,WAAW,QAAQ,MAAM,KAAK,OAAO,KAAK,OAAO,QAAQ;AAGzE,UAAM,iBAAiB,UAAU,KAAK;AAGtC,UAAM,sBAAsB,KAAK,cAAc,gBAAgB;AAG/D,WAAO,KAAK,YAAY,qBAAqB;AAAA;AAAA,QAS9B,cACf,YACA,SACA,aACgB;AAChB,QAAI,YAAY,KAAK,OAAO,WAAW,IAAI;AAE1C,WAAK,WAAW;AAEhB,YAAM,SAAS,KAAK,QAAQ,IAAI,YAAY;AAE5C,UAAI,qBAAqB,SAAS;AACjC,cAAM,gBAAgB,KAAK;AAE3B,cAAM,OAAO,IAAI;AAAA,UAChB;AAAA,UACA,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,UACA,UAAU,KAAK;AAAA,UACf,WAAW,KAAK;AAAA;AAGjB,YAAI,CAAC,KAAK,8BAA8B,SAAS,OAAO,WAAW;AAClE,gBAAM,WAAW,kBAAkB,KAAK,QAAQ,gBAAgB,KAAK;AACrE,gBAAM,cAAc,MAAM,KAAK,YAAY;AAC3C,gBAAM,gBAAgB,WAAW,eAAe,MAAM,YAAY,UAAU,KAAK,OAAO,QAAQ;AAEhG,gBAAM,yBAAyB;AAAA,YAC9B,sBAAsB;AAAA,YACtB,6BAA6B;AAAA,YAC7B,yBAAyB,KAAK,mBAAK,oCAAmC,WAAW;AAAA,YACjF,wBAAwB;AAAA;AAAA;AAAA;AAAA,WAIrB;AACN,YAAM,0BAA0B,MAAM,KAAK,0BAA0B,YAAY,YAAY,MAAM;AAAA,QAClG,QAAQ,YAAY;AAAA,QACpB,SAAS,YAAY;AAAA,QACrB,OAAO,YAAY;AAAA;AAGpB,YAAM,YAAY,MACjB,SAAS,2BACN,0BACA,EAAE,SAAS,yBAAyB,WAAW,MAAM,iBAAiB,EAAE,OAAO,IAAI,OAAO;AAAA;AAAA;AAAA,EAStF,UAAU,GAAqE,QAAsB;AAE9G,SAAK,WAAW;AAGhB,QAAI,KAAK,YAAY,CAAC,kBAAiB,oBAAoB,SAAS,SAAS;AAC5E,WAAK,yBAAyB;AAAA,QAC7B,sBAAsB,KAAK;AAAA,QAC3B,6BAA6B,EAAE,YAAY;AAAA,QAC3C,yBAAyB,KAAK,mBAAK,oCAAmC,WAAW;AAAA,QACjF,wBAAwB,EAAE,YAAY;AAAA,QACtC,eAAe;AAAA,QACf,sBAAsB,EAAE,YAAY;AAAA;AAAA;AAAA;AAAA,EAK7B,YAAY,SAA8C,OAAoD;AACvH,QAAI,CAAC,QAAQ,QAAQ,QAAQ;AAC5B,aAAO;AAAA;AAGR,UAAM,0BAA0B,UAAU,QAAQ;AAElD,eAAW,CAAC,KAAK,UAAU,OAAO,QAAQ,0BAA0B;AACnE,UAAI,OAAO;AACV,cAAM,WAAW,EAAE,MAAM,KAAK,SAAS,SAAS,OAAO,OAAO,QAAQ,QAAQ,KAAK,SAAS,SAAS,IAAI,QAAQ,QAAQ;AACzH,cAAM,OAAO,OAAO,GAAG,KAAK,kBAAkB,GAAG,KAAK,qBAAqB,KAAK,QAAQ,OAAO,KAAK,MAAM,SACzG,MAAM,OAAO,OAAO,IAAI,KAAK,wBAAwB,MAAM,OAAO,SAAS;AAAA;AAAA;AAK9E,WAAO,KAAK,SAAS,QAAQ;AAAA;AAAA,EAGtB,cACP,UACA,SACsC;AACtC,UAAM,YAAY,KAAK,mBAAmB,SAAS,QAAQ,QAAQ;AAEnE,WAAO,KAAK,aAAa,SAAS,QAAQ;AAAA;AAAA,EAGnC,mBACP,eACA,YACkC;AAClC,QAAI,WAAU,aAAa;AAC1B,aAAO,gBAAgB,CAAC,gBAAgB,MAAM;AAAA;AAG/C,QAAI,WAAU,gBAAgB;AAC7B,aAAO;AAAA;AAGR,WAAO,KAAK,YAAY,cAAc,IAAI;AAAA;AAAA,EAGnC,YACP,eACA,YACsD;AACtD,UAAM,eAAoE;AAE1E,eAAW,aAAa,YAAY;AACnC,mBAAa,KAAK;AAAA,QACjB,OAAO,UAAU,SAAS,cAAc,SAAS;AAAA,QACjD,aAAa,UAAU,eAAe,cAAc,eAAe;AAAA,QACnE,KAAK,UAAU,OAAO,cAAc,OAAO;AAAA,QAC3C,WACE,QAAO,UAAU,cAAc,WAAW,IAAI,KAAK,UAAU,aAAa,UAAU,cACpF,QAAO,cAAc,cAAc,WAAW,IAAI,KAAK,cAAc,aAAa,cAAc,cACjG;AAAA,QACD,OAAO,UAAU,SAAS,cAAc,SAAS;AAAA,QACjD,QAAQ,KAAK,YAAY,cAAc,QAAQ,UAAU;AAAA,QACzD,QAAQ,UAAU,UAAU,cAAc,UAAU;AAAA,QACpD,WAAW,UAAU,aAAa,cAAc,aAAa;AAAA,QAC7D,OAAO,UAAU,SAAS,cAAc,SAAS;AAAA,QACjD,OAAO,UAAU,SAAS,cAAc,SAAS;AAAA,QACjD,QAAQ,UAAU,UAAU,cAAc,UAAU;AAAA;AAAA;AAItD,WAAO;AAAA;AAAA,EAGA,YAAe,UAAgB,OAA8B;AACpE,QAAI,WAAU,QAAQ;AACrB,aAAO;AAAA;AAGR,QAAI,WAAU,WAAW;AACxB,aAAO;AAAA;AAGR,WAAO,CAAC,GAAG,UAAU,GAAG;AAAA;AAAA,SAwNV,gBAAgB,UAA0D;AACxF,QAAI,aAAa,QAAW;AAC3B,aAAO;AAAA;AAGR,QAAI,oBAAoB,cAAc;AACrC,aAAO,EAAE,QAAQ,CAAC;AAAA;AAGnB,WAAO;AAAA;AAAA;AA9zCF;AAAA;AAEN;AAimCc,cAnmCR,kBAmmCQ,kBAA2C;AAAA,EACxD;AAAA,IACC,UAAU;AAAA,IACV,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,SAAS,kBAAkB,YAAY,kBAAmB,SAAQ,QAAQ,SAAS,YAAY,OAAO,IAAI;AAAA;AAAA,EAEnH;AAAA,IACC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,cAAe,QAAQ,QAAQ;AAAA;AAAA,EAExC;AAAA,IACC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,cAAc;AACrB,UAAI,QAAQ,UAAU,GAAG;AACxB,gBAAQ,QAAQ,QAAQ,MAAM,SAAS;AAAA,aACjC;AACN,UAAE,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIb;AAAA,IACC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,cAAc;AACrB,UAAI,QAAQ,UAAU,QAAQ,MAAM,SAAS,GAAG;AAC/C,gBAAQ,QAAQ;AAAA,aACV;AACN,UAAE,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIb;AAAA,IACC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,cAAe,QAAQ,QAAQ,QAAQ,MAAM,SAAS;AAAA;AAAA,EAE/D;AAAA,IACC,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM,WAAU,sBAAsB;AAAA,IACtC,KAAK,CAAC,EAAE,gBAAgB;AACvB,gBAAU;AAAA;AAAA;AAAA;AAaC,cApqCR,kBAoqCQ,+BAA8B;AAc9B,cAlrCR,kBAkrCQ,iCAAgC,CAAC;AAMjC,cAxrCR,kBAwrCQ,uBAAsB,CAAC,iBAAiB,iBAAiB;AAezD,cAvsCR,kBAusCQ,mBAAkB;AAelB,cAttCR,kBAstCQ,wBAAuB;AASd,cA/tCjB,kBA+tCiB,YAAW,oBAAI;AASf,cAxuCjB,kBAwuCiB,YAAW,oBAAI;AA2BxB,cAnwCR,kBAmwCQ,qBAA+D,wBAAC,cAAe,GAAE,OAAO,QAAQ,gBAAjC;AA4C/D,cA/yCR,kBA+yCQ,6BAA+E,wBAAC,eAAsB;AAAA,EACnH,SAAS,kFAAkF,WAAW,YAAY,WAAW;AAAA,EAC7H,WAAW;AAAA,EACX,iBAAiB,EAAE,OAAO,IAAI,OAAO;AAAA,IAHuD;;;ADx5CvF,yCAAmC,iBAAiB;AAAA,QAIpC,oBAAmC;AACxD,UAAM,KAAK,YAAY,KAAK;AAAA;AAAA,QAOP,YAAY,OAA8C;AAC/E,UAAM,WAAW,CAAC,MAAM,YAAY;AACpC,QAAI,KAAK,QAAQ,QAAQ;AAAI,eAAS,KAAK,MAAM,YAAY,QAAQ;AACrE,QAAI,KAAK,QAAQ,QAAQ;AAAI,eAAS,KAAK,MAAM,YAAY,QAAQ;AAErE,UAAM,CAAC,UAAU,MAAM,QAAQ,IAAI;AACnC,WAAO;AAAA;AAAA,EAGQ,eAAe,SAA+E;AAC7G,WAAO,KAAK,QAAQ,MAAO,YAAW,WAAW,QAAQ,IAAI,oBAAoB;AAAA;AAAA,EAGlE,eAAe,SAAuB;AACrD,WAAO,KAAK,QAAQ,MAAO,GAAE;AAAA;AAAA,EAGd,aAAa,OAAuE;AACnG,WAAO,KAAK,QAAQ,MAAO,GAAE,QAAQ,OAAO,UAAU,aAAa,CAAC,MAAM,IAAI,oBAAmB,CAAC;AAAA;AAAA,EAGnF,cACf,QAcO;AACP,WAAO,KAAK,QAAQ,MAAM;AACzB,UAAI,kBAAkB,YAAW,UAC9B,OACA,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,iBACJ,IAAI,mBAEJ;AAEH,UAAI,gBAAgB,SAAS,IAAI;AAChC,0BAAkB,gBAAgB,MAAM,GAAG;AAAA;AAG5C,aAAO,EAAE,QAAQ;AAAA;AAAA;AAAA;AArEb;;;AGTP;AACA;AA6BO,+CAA4C,iBAAiB;AAAA,EAA7D,cA9BP;AA8BO;AACE,yCAA8B,IAAI;AAClC,sCAAa;AACb,iCAAa;AACb,wCAAe;AACf,sCAAa;AAAA;AAAA,EAMd,SAAS,OAAY;AAC3B,SAAK,QAAQ;AACb,WAAO;AAAA;AAAA,EAOD,cAAc,OAAe;AACnC,SAAK,aAAa;AAClB,WAAO;AAAA;AAAA,EAOD,gBAAgB,cAAsB;AAC5C,SAAK,eAAe;AACpB,WAAO;AAAA;AAAA,EAwBD,YAAY,UAAwF;AAC1G,SAAK,gBAAgB,KAAK,gBAAgB;AAC1C,WAAO;AAAA;AAAA,EAwBD,YAAY,WAAwD;AAC1E,SAAK,QAAQ,KAAK,MAAM,IAAI;AAC5B,WAAO;AAAA;AAAA,EAyBD,OAAO;AACb,QAAI,CAAC,KAAK,WAAW;AAAQ,YAAM,IAAI,MAAM;AAC7C,QAAI,CAAC,KAAK,MAAM;AAAQ,YAAM,IAAI,MAAM;AACxC,QAAI,KAAK,MAAM,KAAK,CAAC,MAAM,CAAC;AAAI,YAAM,IAAI,MAAM;AAEhD,SAAK,aAAa,KAAK,KAAK,KAAK,MAAM,SAAS,KAAK;AACrD,SAAK;AACL,WAAO;AAAA;AAAA,EAGA,gBAAgB;AACvB,UAAM,WAAW,KAAK,yBAAyB,gBAAgB,KAAK,cAAc,WAAmC,KAAK;AAC1H,aAAS,IAAI,GAAG,IAAI,KAAK,YAAY,KAAK;AACzC,YAAM,iBAAiB,IAAI,cAAa;AACxC,YAAM,cAAc,KAAK,cAAc;AACvC,qBAAe,SAAS;AAExB,UAAI,CAAC,eAAe;AAAO,uBAAe,SAAS;AAEnD,YAAM,OAAO,KAAK,cAAc,KAAK,OAAO,GAAG,KAAK;AACpD,WAAK,QAAQ;AAAA,QACZ,QAAQ,CAAC,eAAe,SAAS,KAAK,YAAY,KAAK,KAAK,OAAO,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA,EAK/E,cAAc,OAAY,aAAqB,cAAsB;AAC5E,UAAM,SAAS,cAAc;AAC7B,WAAO,MAAM,MAAM,QAAQ,SAAS;AAAA;AAAA,EAG7B,gBAAgB,UAAwF;AAC/G,QAAI,oBAAoB,eAAc;AACrC,aAAO;AAAA;AAGR,QAAI,YAAW,WAAW;AACzB,aAAO,SAAS,IAAI;AAAA;AAGrB,WAAO,IAAI,cAAa;AAAA;AAAA;AApJnB;;;AC9BP;AACA;AACA;AA0BO,gDAA0C,iBAAiB;AAAA,EAA3D,cA5BP;AA4BO;AACE,yCAA8B,IAAI;AAClC,sCAAa;AACb,iCAA0B;AAC1B,wCAAe;AAAA;AAAA,EAMhB,SAAS,OAA+B;AAC9C,SAAK,QAAQ;AACb,WAAO;AAAA;AAAA,EAOD,gBAAgB,cAA4B;AAClD,SAAK,eAAe;AACpB,WAAO;AAAA;AAAA,EAiCD,YAAY,UAA8F;AAChH,SAAK,gBAAgB,KAAK,gBAAgB;AAC1C,WAAO;AAAA;AAAA,EAuBD,OAAa;AACnB,QAAI,CAAC,KAAK,MAAM;AAAQ,YAAM,IAAI,MAAM;AACxC,QAAI,KAAK,eAAe,YAAY;AAAe,YAAM,IAAI,MAAM,kCAAkC,YAAY;AAEjH,SAAK,aAAa,KAAK,KAAK,KAAK,MAAM,SAAS,KAAK;AACrD,SAAK;AACL,WAAO;AAAA;AAAA,EAGA,gBAAsB;AAC7B,UAAM,WAAW,KAAK,yBAAyB,gBAAgB,KAAK,cAAc,WAAmC,KAAK;AAC1H,aAAS,IAAI,GAAG,IAAI,KAAK,YAAY,KAAK;AACzC,YAAM,iBAAiB,IAAI,cAAa;AACxC,YAAM,cAAc,KAAK,cAAc;AACvC,qBAAe,SAAS;AAExB,UAAI,CAAC,eAAe;AAAO,uBAAe,SAAS;AAEnD,YAAM,OAAO,KAAK,cAAc,KAAK,OAAO,GAAG,KAAK,eAAe,YAAY;AAC/E,WAAK,QAAQ;AAAA,QACZ,QAAQ,CAAC,eAAe,UAAU,GAAG,MAAM,GAAG;AAAA;AAAA;AAAA;AAAA,EAKzC,cAAc,OAAyB,aAAqB,cAAwC;AAC3G,UAAM,SAAS,cAAc;AAC7B,WAAO,MAAM,MAAM,QAAQ,SAAS;AAAA;AAAA,EAG7B,gBAAgB,UAAwF;AAC/G,QAAI,oBAAoB,eAAc;AACrC,aAAO;AAAA;AAGR,QAAI,YAAW,WAAW;AACzB,aAAO,SAAS,IAAI;AAAA;AAGrB,WAAO,IAAI,cAAa;AAAA;AAAA;AAtHnB;;;AC5BP;AACA;AAIA,IAAM,6BAA6B,IAAI,YAAY,CAAC;AAO7C,yBAAyB,SAA0C;AACzE,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AAEjC,SAAO,aAAa,SAAS;AAAA;AAJd;AAOhB,IAAM,6BAA6B,IAAI,YAAY,CAAC,4BAA4B;AAOzE,yBAAyB,SAA0C;AACzE,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AACjC,MAAI,QAAQ,cAAc,CAAC,QAAQ;AAAU,WAAO;AAEpD,SAAO,aAAa,SAAS;AAAA;AALd;AAQhB,IAAM,2BAA2B,IAAI,YAAY,CAAC,4BAA4B;AAOvE,uBAAuB,SAA0C;AACvE,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AACjC,MAAI,QAAQ,cAAc,CAAC,QAAQ;AAAU,WAAO;AAEpD,SAAO,aAAa,SAAS;AAAA;AALd;AAQhB,IAAM,gCAAgC,IAAI,YAAY,CAAC,4BAA4B;AAO5E,4BAA4B,SAA0C;AAC5E,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AACjC,MAAI,QAAQ,cAAc,CAAC,QAAQ;AAAU,WAAO;AAEpD,SAAO,aAAa,SAAS;AAAA;AALd;AAQhB,IAAM,sBAAsB,IAAI,YAAY,CAAC,4BAA4B,wBAAwB;AAO1F,kBAAkB,SAAiC;AACzD,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AACjC,MAAI,QAAQ,cAAc,QAAQ;AAAU,WAAO;AAEnD,SAAO,aAAa,SAAS;AAAA;AALd;AAQhB,IAAM,mCAAmC,IAAI,YAAY,CAAC,4BAA4B,wBAAwB;AAOvG,+BAA+B,SAAiC;AACtE,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,YAAY;AAAU,WAAO;AAEjC,SAAO,aAAa,SAAS;AAAA;AAJd;AAOhB,IAAM,iCAAiC,IAAI,YAAY,CAAC;AAOjD,6BAA6B,SAA+C;AAClF,MAAI,WAAU;AAAU,WAAO;AAC/B,MAAI,CAAC,oBAAoB;AAAU,WAAO;AAC1C,MAAI,QAAQ,aAAa,QAAQ,QAAQ;AAAM,WAAO;AAEtD,SAAO,aAAa,SAAS;AAAA;AALd;AAQhB,sBAAsB,SAAuB,mBAAgC;AAC5E,SAAO,oBAAoB,WAAW,QAAQ,eAAe,QAAQ,MAAM,IAAM,IAAI,qBAAqB;AAAA;AADlG;","names":[]}